(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Vectors`VectorsLog=False;
Needs["Vectors`","RNL`Vectors`"];
Needs["LinearFunctions`","RNL`LinearFunctions`"];


SetAttributes[SmallCircle,{Flat,OneIdentity}];
SetLinearIn[FreeQ[#,LiteRed`A|LiteRed`B]&,SmallCircle,All];
SmallCircle[a___,1,b___]:=SmallCircle[a,b];
LFRules=Union[LFRules,{sc_SmallCircle/;Length[sc]<2:>Times@@sc}];


Needs["Numbers`","RNL`Numbers`"];
Needs["Types`","RNL`Types`"];
BeginPackage["LiteRed`",{"Vectors`","LinearFunctions`","Numbers`","Types`"}]


$LiteRedVersion="1.82";
$LiteRedReleaseDate="01.06.2015";
$LiteRedVersion::usage="$LiteRedVersion is the current version of the LiteRed package.";
$LiteRedReleaseDate::usage="$LiteRedReleaseDate is the release date of the current version.";


NewBasis;
	Ds;
	LMs;
	EMs;
	SPs;
    MIs;
    Toj;(*Toj[nm]*)
    BasisDirectory;
    Definitions;
ExecuteDefinitions;
CheckDefinitions;


j;
Toj;
Fromj;


A;B;ToAB;FromAB;
(*FromTildeAB;AtoLeft;*)
(*InverseTildeConjugate;
TildeConjugate;*)
ABIBP;ABLI;ABIBPLI;


jsOrder;
jComplexity;
jVars;
Highj;Highjs;
HighjIndex;


Collectj;CollectjList;
SimplifyFunction;SimplifyAlways;jPattern;
Factor1;Factor2;Factor3;


Solvej;SolvejSector;
	SubstituteAlways;
	CheckZeroAlways;
	CheckZeroFunction;
	NMIs;
(*UseRules;*)


js;
jSector;


GenerateIBP;
	IBP;
	LI;
	IBPLI;


AnalyzeSectors;
    ZeroSectors;
    NonZeroSectors;
    SimpleSectors;
    BasisSectors;
    ZerojRule;
	CutDs;
(*AnalyzeSectorsFP;*)


FindSymmetries;
    UniqueSectors;
    MappedSectors;
    jSymMatrices;
    jSymmetries;
    jRules;
    SR;
    jsOrderingFunction;


IdentifyMIs;


FindExtSymmetries;
    ExtUniqueSectors;
    ExtMappedSectors;
    jExtRules;


AttachGraph;
jGraph;


FeynParUF;FeynParUFFunction;


PolyNForm;
PolyVPInv;
PolyMapToVPInv;


NamingFunction


DiskSave;
DiskRecover;


IBPReduce;
    (*DWeight;*)


ToMIsRule;


ToDShifts;FromDShifts;


LoweringDRR;RaisingDRR;
Dinv;


GramP;GramPFunction;


$LiteRedLog::usage="$LiteRedLog=True turns on some log information of the package.";
$LiteRedMonitor::usage="$LiteRedMonitor=True turns on some temporary log information of the package.";
If[!ValueQ[$LiteRedLog],$LiteRedLog=True];
If[!ValueQ[$LiteRedMonitor],$LiteRedMonitor=True];


$NamingFunction::usage="$NamingFunction is a global naming function for the symbolic indices of the integral. The argument is the length of the index list.\
By default it is set so that, e.g., $NamingFunction[5] returns {n1,n2,n3,n4,n5}.\n\
To change to default definition, use $NamingFunction=(\[Ellipsis])&.";


$NamingFunction=Array[ToExpression["n"<>ToString[#]]&,{#}]&;


LiteRed`Private`LiteRedPrint=If[$LiteRedLog,Print[##]]&;
LiteRed`Private`LiteRedPrintTemporary=If[$LiteRedLog,PrintTemporary[##]]&;
LiteRed`Private`LiteRedMonitor:=If[$LiteRedMonitor,Monitor,#&];
LiteRed`Private`LiteRedPrint["**************** ",Style["LiteRed v"<>ToString[$LiteRedVersion],{Bold,Lighter@Red}]," ********************\n\
Author: Roman N. Lee, Budker Institute of Nuclear Physics, Novosibirsk.\n\
Release Date: "<>$LiteRedReleaseDate<>"\n\
LiteRed stands for Loop InTEgrals REDuction.\n\
The package is designed for the search and application of the Integration-By-Part reduction rules. \
It also contains some other useful tools.\n\
See ?LiteRed`* for a list of functions. "];


Begin["`Private`"]


(* added 21.12.2012 *)
PutUpValues[b_,fn_]:=Put@@Append[Unevaluated@@@Apply[TagSetDelayed,Hold/@(Prepend[ReplacePart[Hold@@#,{1,0}->Sequence],b]&/@UpValues[b]),{2}],fn];
PutAppendUpValues[b_,fn_]:=PutAppend@@Append[Unevaluated@@@Apply[TagSetDelayed,Hold/@(Prepend[ReplacePart[Hold@@#,{1,0}->Sequence],b]&/@UpValues[b]),{2}],fn];
(*/added 21.12.2012 *)


If[Not[NameQ["Compositions"]],
SetSharedFunction[Symbol["Compositions"]];
Symbol["Compositions"][0,0]={{}};
Symbol["Compositions"][n_Integer?Positive,0]={};Symbol["Compositions"][n_Integer,k_Integer?Positive] :=
	Map[
		(Map[(#[[2]]-#[[1]]-1)&, Partition[Join[{0},#,{n+k}],2,1] ])&,
		Subsets[Range[n+k-1],{k-1}]
	]
]


If[Not[NameQ["SplitCases"]],
SetSharedFunction[Symbol["SplitCases"]];
Evaluate[Symbol["SplitCases"]]::usage="SplitCases[\!\(\*
StyleBox[\"list\", \"TI\"]\),{\!\(\*
StyleBox[\"pat1\", \"TI\"]\),\!\(\*
StyleBox[\"pat2\", \"TI\"]\),\[Ellipsis]}] splits \!\(\*
StyleBox[\"list\", \"TI\"]\) into parts, matching patterns \!\(\*
StyleBox[\"pat1\", \"TI\"]\),\!\(\*
StyleBox[\"pat2\", \"TI\"]\),\[Ellipsis],_.";
Symbol["SplitCases"][l_,ps_List] :=
	Module[{pn},
{Sequence@@Last/@SortBy[#2,First@#&],#1}&@@Reap[Replace[l,MapThread[(Sow[pn,Symbol["SplitCases"]@#2];pn:#:>(Sow[pn,Symbol["SplitCases"]@#2];
Unevaluated[Sequence[]]))&,
{ps,Range[Length[ps]]}],{1}],Blank[Symbol["SplitCases"]],{First@#1,Head@l@@(#2/.pn->Sequence[])}&]]
]


Unflatten[list_List,tmpl_List]:=Module[{fn,f,i=1},
SetAttributes[fn,HoldAll];
fn[x_List]:=fn/@x;
fn[x_]:=Slot[i++];
(f[fn[tmpl]]/.f->Function)@@list
]


NamingFunction::usage="NamingFunction\[Rule]f is an option which determines the naming convention for indices and parameters in several functions.\n\
The function \!\(\*
StyleBox[\"f\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"n\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is assumed to give a list of \!\(\*
StyleBox[\"n\", \"TI\"]\) parameters.\n\ NamingFunction\[Rule]Automatic uses the global naming function as defined in $NamingFunction.";


NewBasis::usage="NewBasis[\!\(\*
StyleBox[\"basis\", \"TI\"]\),denominators_List,loopMomenta_List] determines a basis.\n\
First argument is a basis basis.\n\
Second argument is a complete set of independent denominators. Shortcuts are allowed here: for the massless propagator sp[l,l]
just put l in the list. sp[a,b] stands for the scalar product of two vectors, sp[a]is a shortcut for sp[a,a].\n\
Third argument is the list of loop momenta.\n\
Options:\n\
    GenerateIBP\[Rule]True|False \[LongDash] determines whether to generate IBPs afterward,\n\
    AnalyzeSectors\[Rule]True|False \[LongDash] determines whether to find zero sectors,\n\
    FindSymmetries\[Rule]True|False \[LongDash] determines whether to find symmetries,\n\
    DiskSave\[Rule]False|\!\(\*
StyleBox[\"dirname\", \"TI\"]\) \[LongDash] determines the directory in which the basis is saved.\n\
    Append\[Rule]False|True \[LongDash] determines whether to append irreducible numerators if needed.";
Ds::usage="Ds[basis] gives a list of denominators in basis.\n\
Ds[j[\[Ellipsis]]] and Ds[js[\[Ellipsis]]] give a list of denominators in j[\[Ellipsis]] and js[\[Ellipsis]].";
SPs::usage="SPs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of scalar products involving loop momenta in basis.";
LMs::usage="LMs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of loop momenta in \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
EMs::usage="EMs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of external momenta in \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
MIs::usage="MIs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of master integrals of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) so far revealed.";
BasisDirectory::usage="BasisDirectory[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the directory in which the definitions of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) will be save with DiskSave[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";
Definitions::usage="Definitions[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] keeps external definitions required by \!\(\*
StyleBox[\"basis\", \"TI\"]\).";


Options[NewBasis]={GenerateIBP->False,AnalyzeSectors->False,FindSymmetries->False,Directory->False,Append->False};


NewBasis::notb="Overdetermined set of denominators. Not a basis. Aborting...";
NewBasis::nums="The set of denominators is not a basis.\nAdd irreducible numerator(s) `1`, or try your own set of `2` numerator(s).\nAborting...";
NewBasis::ovrw="Warning: definitions for `1` has been found. They may interfere with the upcoming definitions.";
NewBasis[nm_Symbol, ds : {(_?VecQ | _?NumQ) ..}, lms : {__?VecVarQ}, 
  OptionsPattern[]] := Module[{nds = Length[ds],d=MetricTensor[], dens, ddens,dim, ems, sps, toj,ns,l},
If[Length@UpValues[nm]>0,Message[NewBasis::ovrw,nm]];
(*Normalize denominators*)
dens = Replace[ds,x_?VecQ :> sp[x, x], {1}];
ems = Complement[Union@Cases[dens, _?VecVarQ, Infinity], lms];
 sps = Union @@ Outer[sp, lms, Join[lms, ems]];
ddens=Expand@LFDistribute[dens,sp];
dim=Length@dens;ns=Length@sps-dim;
(*add numerators*)
If[ns<0,Message[NewBasis::notb]; Abort[]];
If[MatrixRank[Coefficient[ddens, #] & /@ sps]<dim,Message[NewBasis::notb]; Abort[]];
If[ns>0,
Quiet[ns=Complement[sps,Solve[ddens==0,sps][[1,All,1]]]];
If[TrueQ[!OptionValue[Append]],Message[NewBasis::nums,ns,Length@ns]; Abort[]];
dens=Join[dens,ns];ddens=Join[ddens,ns];
dim=Length@sps;
LiteRedPrint["Irreducible numerator(s) appended: ",Sequence@@Riffle[ns,","],".\nPattern for AnalyzeSectors: {___,"<>StringTake[ToString[0&/@ns],{2,-1}]];];(*/add numerators*)
(*Definitions 21.11.13*)
l=DeleteCases[{Sort[{##}],Replace[sp[##],sp->List,{1},Heads->True]}&@@@Replace[Subsets[ems,{1,2}],{x_}:> {x,x},{1}],{l_,l_}];
Definitions[nm]^=Flatten[{If[AtomQ[MetricTensor[]],Hold[MetricTensor[]===#,SetDim[#]]&[MetricTensor[]],Unevaluated[Sequence[]]],
Hold[VecQ[#],Declare[#,Vector]]&/@Join[lms,ems],
Hold[TypeOf[#]===#2,Declare[#,#2]]&@@@({#,TypeOf[#]}&/@Select[Variables[l],AtomQ]),
Replace[l,{{x_,y_},z_}:>Hold[sp[x,y]===z,sp[x,y]=z],{1}]}];
(*/Definitions 21.11.13*)
(*If[dim != Length[sps] || Det[Coefficient[ddens, #] & /@ sps] == 0,Message[NewBasis::notb];Abort[]];*)
{toj}=Solve[MapIndexed[#1 == (j[nm, ##] & @@ (-IntegerDigits[2^(dim - First@#2), 2, dim])) &,ddens], sps];
nm /: Ds[nm] = dens;
nm /: SPs[nm] = sps;
nm /: LMs[nm] = lms;
nm /: EMs[nm] = ems;
nm/:Toj[nm]=toj;
jSector[nm]=js@@Prepend[ConstantArray[1,nds],nm];
MIs[nm]^={};
SR[nm]^={}&;
BasisDirectory[nm]=OptionValue[Directory];
nm::usage=ToString[Length@lms]<>"-loop basis with "<>ToString[Length@ems]<>" external momenta.\nUse Information["<>ToString[nm]<>"] to get basis summary.\nThis string can be redefined by setting "<>ToString[nm]<>"::usage=\"\[Ellipsis]\"";
nm/:Information[nm]:=(If[ValueQ[nm::usage],Information[nm,LongForm->False]];
Print@Grid[Partition[Union[Replace[Replace[First/@UpValues[nm]/.HoldPattern->HoldForm,{HoldPattern[HoldForm[f_[nm,__]]]:>HoldForm[f[nm,"\[Ellipsis]"]]},{1}],{HoldPattern[x:HoldForm[f_[nm,___]]]:>Button[x,(SelectionMove[ButtonNotebook[],All,GeneratedCell];NotebookDelete[];Information[Evaluate@x[[1,0]],LongForm->False];Print[TableForm[Cases[UpValues[nm],HoldPattern[a_:>b_]/;MatchQ[a[[1,0]],x[[1,0]]]]/.HoldPattern->HoldForm]])&,Appearance->"Frameless",BaseStyle->"InformationLink"]},{1}]],5],DefaultBaseStyle->"InfoGrid"]);
(*default syntax*)
nm[j,inds__]:=j[nm,inds];
nm[js,inds__]:=js[nm,inds];
SyntaxInformation[nm]={"ArgumentsPattern"->(ConstantArray[_,Length@dens+1])};
(*default syntax*)
LiteRedPrint["Valid basis.\n    Ds[" <> # <>"] \[LongDash] denominators,\n    SPs[" <> # <>"] \[LongDash] scalar products involving loop momenta,\n    LMs[" <> # <>"] \[LongDash] loop momenta,\n    EMs[" <> # <>"] \[LongDash] external momenta,\n    Toj[" <> # <>"] \[LongDash] rules to transform scalar products to denominators."<>(If[Not@TrueQ@Not@BasisDirectory[nm],"\nThe definitions of the basis will be saved in "<>BasisDirectory[nm],""])] &@ToString[nm];
(*Options processing*)
If[Not@TrueQ@Not@BasisDirectory[nm],DiskSave[nm,Save->"Basis"]];
If[TrueQ@OptionValue[FindSymmetries]||TrueQ@OptionValue[AnalyzeSectors]||TrueQ@OptionValue[GenerateIBP],GenerateIBP[nm]];
If[TrueQ@OptionValue[FindSymmetries]||TrueQ@OptionValue[AnalyzeSectors],AnalyzeSectors[nm]];
If[TrueQ@OptionValue[FindSymmetries],FindSymmetries[nm]];
(*/Options processing*)
];


MIs[nm_,n:(0|1)..]:=Select[MIs[nm],jSector[#]==js[nm,n]&];
MIs[sec_js]:=MIs@@sec;


Ds[js[nm_,x:(0|1)..]]:=Pick[Ds[nm],{x},1];
Ds[j[nm_,x__Integer]]:=Pick[Ds[nm],{x},_?Positive];
Ds[jj_j]:=Ds[jSector@jj];


ExecuteDefinitions::usage="ExecuteDefinitions[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] executes external definitions required by \!\(\*
StyleBox[\"basis\", \"TI\"]\): declares variables, sets dimensionality and scalar products.";
ExecuteDefinitions::nodefs="No definitions found.";
Options[ExecuteDefinitions]={Print->False};
ExecuteDefinitions[nm_,OptionsPattern[]]:=Module[{pr=OptionValue[Print]},
If[ValueQ[Definitions[nm]],
If[!ReleaseHold[#1],If[TrueQ@pr,Print["Condition ",#1, " is not satisfied. Executing ",Style[#2,Bold],"."]];ReleaseHold[#2]]&@@@((HoldForm/@#)&/@Definitions[nm]);,
Message[ExecuteDefinitions::nodefs];
]
]


CheckDefinitions::usage="CheckDefinitions[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] checks external definitions required by \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
CheckDefinitions::warn="Some external definitions used in '`1`' basis are missing. Probably, you should run ExecuteDefinitions[`1`].";
CheckDefinitions[nm_]:=
Module[{f=checkdefs[nm]},If[f=!={},Print["    Condition ",#1, " is not satisfied. Needs executing ",Style[#2,Bold],"."]&@@@f;Print["Probably, you should run ExecuteDefinitions["<>ToString[nm]<>"]"]];];


CheckDefs[nm_]:=Module[{f=checkdefs[nm]},If[f=!={},Message[CheckDefinitions::warn,nm]];];


checkdefs[nm_]:=If[ValueQ[Definitions[nm]],If[!ReleaseHold[#1],{#1,#2},Unevaluated[Sequence[]]]&@@@((HoldForm/@#)&/@Definitions[nm]),
Message[ExecuteDefinitions::nodefs];{}]


DiskSave::usage="DiskSave[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"dir\", \"TI\"]\)] saves to disk memory-consuming definitions for the basis at the cost of speed.It can be used also to save the basis to reuse it later.\nDiskSave[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] saves definitions to BasisDirectory[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]\nOptions:\n    Save\[Rule](All|\"Basis\"|\"jRules\"|\"Sectors\"|\"Identities\"|{\"Basis\"|\"jRules\"|\"Sectors\"|\"Identities\"}) \[LongDash] determines what definitions to save. Save\[Rule]\"Basis\" saves the basis for further reuse. The default is Save\[Rule]All;\n    Replace\[Rule]True|False \[LongDash] determines whether to overwrite existing files.";


Options[DiskSave]={Save->All,Replace->True};
DiskSave::dir="The directory `1` has been created.";
DiskSave::nodir="The directory for `1` has not been set. Use BasisDirectory[`1`]=\!\(\*
StyleBox[\"dirname\", \"TI\"]\).";
DiskSave::overwrite="The file `1` has been overwritten.";
DiskSave::warn="Warning: the file `1` exists. The basis has not been saved.";
DiskSave::optx="Unknown option value `1`.";


DiskSave[nm_,opts:OptionsPattern[]]:=
Module[
{t=Alternatives[],dir,tb=False,t1,t2,t3},
If[TrueQ@Not@BasisDirectory[nm],Message[DiskSave::nodir,nm];Return[False]];
dir=BasisDirectory[nm];
Replace[OptionValue[Save],
{All|Max:>(t="HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"|"HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"|"HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*";tb=True),
"Basis"|Min:>(tb=True),
"jRules":>(t="HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"),
"Sectors":>(t="HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"),
"Identities":>(t="HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*"),
x:{("jRules"|"Sectors"|"Identities"|"Basis")..}:>(
If[MemberQ[x,"jRules"],t=t|"HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"];
If[MemberQ[x,"Sectors"],t=t|"HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"];
If[MemberQ[x,"Identities"],t=t|"HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*"];
If[MemberQ[x,"Basis"],tb=True];
), 
x_:>Message[DiskSave::optx,Save->x]
}
];
If[!DirectoryQ[dir],CreateDirectory[dir];Message[DiskSave::dir,dir]];
If[t=!=Alternatives[],
(t1=ToString[First@#];t2=Last@MapAt[Hold,#,{2}];
If[StringMatchQ[t1,t],
If[t2[[1,0]]=!=Get,
t3=StringTake[t1,{13,-2}];
If[!FileExistsQ[dir<>"/"<>t3]||OptionValue[Replace],
If[FileExistsQ[dir<>"/"<>t3],Message[DiskSave::overwrite,t3]];
ReleaseHold[ReplacePart[Hold[Put[##]],{1,1,0}->Unevaluated]]&[t2,dir<>"/"<>t3];
ToExpression[ToString[nm]<>"/:"<>StringTake[t1,{13,-2}]<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>"<>"\"/"<>t3<>"\"]"];
]
];
])&/@UpValues[nm]];
If[tb,
t3=dir<>"/"<>ToString[nm];
If[!FileExistsQ[t3]||OptionValue[Replace],If[FileExistsQ[t3],Message[DiskSave::overwrite,t3]];Put[Unevaluated[BasisDirectory[nm]=StringDrop[DirectoryName[$Input],-1]],t3];(* modified 21.12.2012 *)(*PutAppend[Definition[nm],t3]*)
PutAppendUpValues[nm,t3](*/modified 21.12.2012 *);If[ValueQ[nm::usage],PutAppend[Unevaluated[nm::usage=#;Information[nm,LongForm->False];],t3]&[nm::usage]];PutAppend[Unevaluated[CheckDefs[nm]],t3];PutAppend[Unevaluated[BasisDirectory[nm]],t3],
Message[DiskSave::warn,t3];
]
];
];


DiskSave[nm_,dir_String,OptionsPattern[]]:=Module[
{t=Alternatives[],tb=False,t1,t2,t3},
Replace[OptionValue[Save],
{All|Max:>(t="HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"|"HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"|"HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*";tb=True),
"Basis"|Min:>(tb=True),
"jRules":>(t="HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"),
"Sectors":>(t="HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"),
"Identities":>(t="HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*"),
x:{("jRules"|"Sectors"|"Identities"|"Basis")..}:>(
If[MemberQ[x,"jRules"],t=t|"HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"];
If[MemberQ[x,"Sectors"],t=t|"HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"];
If[MemberQ[x,"Identities"],t=t|"HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*"];
If[MemberQ[x,"Basis"],tb=True];
), 
x_:>Message[DiskSave::optx,Save->x]
}
];
If[!DirectoryQ[dir],CreateDirectory[dir];Message[DiskSave::dir,dir]];
If[t=!=Alternatives[],
(t1=ToString[First@#];t2=Last@MapAt[Hold,#,{2}];
If[StringMatchQ[t1,t],
If[t2[[1,0]]=!=Get,
t3=dir<>"/"<>StringTake[t1,{13,-2}];
If[!FileExistsQ[t3]||OptionValue[Replace],
If[FileExistsQ[t3],Message[DiskSave::overwrite,t3]];
ReleaseHold[ReplacePart[Hold[Put[##]],{1,1,0}->Unevaluated]]&[t2,t3];
ToExpression[ToString[nm]<>"/:"<>StringTake[t1,{13,-2}]<>":=Get["<>"\""<>t3<>"\"]"];
]
];
])&/@UpValues[nm]];
If[tb,
t3=dir<>"/"<>ToString[nm];
If[!FileExistsQ[t3]||OptionValue[Replace],If[FileExistsQ[t3],Message[DiskSave::overwrite,t3]];(* modified 21.12.2012 *)(*Put[Definition[nm],t3]*)PutUpValues[nm,t3](*/modified 21.12.2012 *),
Message[DiskSave::warn,t3];
]
];
]


DiskRecover::usage="DiskRecover[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] recovers from disk memory-consuming definitions.\n\
Options:\n\
    Get\[Rule](All|\"jRules\"|\"Sectors\"|\"Identities\"|{\"jRules\"|\"Sectors\"|\"Identities\"})\
 \[LongDash] determines what definitions to recover. The default is Get\[Rule]All;\n\
    Remove\[Rule]True|False \[LongDash] determines whether to remove files afterwards.";


Options[DiskRecover]={Get->All,Remove->True};
DiskRecover::warn="Warning: the file `1` does not exists.";
DiskRecover::optx="Unknown option value `1`.";


DiskRecover[nm_,OptionsPattern[]]:=Module[
{t=Alternatives[],t1,t2,t3},
Replace[OptionValue[Get],
{All|Max:>(t="HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"|"HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"|"HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*"),
"jRules":>(t="HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"),
"Sectors":>(t="HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"),
"Identities":>(t="HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*"),
x:{("jRules"|"Sectors"|"Identities")..}:>(
If[MemberQ[x,"jRules"],t=t|"HoldPattern[jRules[*"|"HoldPattern[jExtRules[*"|"HoldPattern[jSymmetries[*"|"HoldPattern[jSymMatrices[*"];
If[MemberQ[x,"Sectors"],t=t|"HoldPattern[ZeroSectors[*"|"HoldPattern[NonZeroSectors[*"|"HoldPattern[SimpleSectors[*"|"HoldPattern[BasisSectors[*"|"HoldPattern[UniqueSectors[*"|"HoldPattern[MappedSectors[*"];
If[MemberQ[x,"Identities"],t=t|"HoldPattern[IBP[*"|"HoldPattern[LI[*"|"HoldPattern[SR[*"];
), 
x_:>Message[DiskRecover::optx,Get->x]
}
];
If[t=!=Alternatives[],
(t1=ToString[First@#];t2=Last@MapAt[Hold,#,{2}];
If[StringMatchQ[t1,t],
If[t2[[1,0]]===Get,
t3=t2[[1,1]];
If[FileExistsQ[t3],
ToExpression[ToString[nm]<>"/:"<>StringTake[t1,{13,-2}]<>"=Get["<>"\""<>t3<>"\"]"];
If[OptionValue[Remove],DeleteFile[t3]],
Message[DiskRecover::warn,t3]
]
];
])&/@UpValues[nm]];
]


j::usage="j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"n1\", \"TI\"]\),\!\(\*
StyleBox[\"n2\", \"TI\"]\),\[Ellipsis]] denotes the integrand of the loop integral in \!\(\*
StyleBox[\"basis\", \"TI\"]\). \
Integer indices \!\(\*
StyleBox[\"n1\", \"TI\"]\),\!\(\*
StyleBox[\"n2\", \"TI\"]\),\[Ellipsis] denote powers of denominators. Negative values correspond to numerators.\n\
To compare the complexity of the integrals, use operators <,>,\[LessEqual],\[GreaterEqual].";


j/:Power[j[nm_,\[Alpha]__],\[Beta]_/;\[Beta]=!=0]:=j[nm,##]&@@(\[Beta]*{\[Alpha]});
j/:j[nm_,\[Alpha]__]*j[nm_,\[Beta]__]:=j[nm,##]&@@({\[Alpha]}+{\[Beta]});


Toj::usage="Toj[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives rules to transform scalar products to denominators of the basis \!\(\*
StyleBox[\"basis\", \"TI\"]\).\n\
Toj[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"expr\", \"TI\"]\)] transforms \!\(\*
StyleBox[\"expr\", \"TI\"]\) to linear combination j[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)].";


Fromj::usage="Fromj[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] rewrites all j[\[Ellipsis]] in \!\(\*
StyleBox[\"expr\", \"TI\"]\) via scalar products."


Toj[nm_,expr_]:=Module[{},Collect[ExpandAll@Factor[j[nm,Sequence@@(0&/@Ds@nm)]*(LFDistribute[expr,sp]/.Toj[nm])],_j,Factor]];
Fromj[js[nm_,x:(0|1)...]]:=Pick[Ds[nm],{x},1];
Fromj[expr_]:=expr/.j[nm_,x:Except[_List]..]:>Times@@((Ds[nm])^(-{x}));


jsOrder::usage="jsOrder[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,...] determines the ordering in the specific sector. Default is {1,2,3,...}.";


jsOrder[nm_,ns:(0|1)...]:=Range[Length@{ns}];


jComplexity::usage="jComplexity[j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"indices\", \"TI\"]\)]] gives a complexity level of the integral, which is {\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"#\", \"TI\"]\)\!\(\*
StyleBox[\"denominators\", \"TI\"]\),\!\(\*
StyleBox[\"\[CapitalSigma]all_powers\", \"TI\"]\),\!\(\*
StyleBox[\"\[CapitalSigma]num_powers\", \"TI\"]\),\!\(\*
StyleBox[\"powers\", \"TI\"]\)}.\n\
\!\(\*
StyleBox[\"powers\", \"TI\"]\) is a sequence of \!\(\*
StyleBox[\"indices\", \"TI\"]\) with each index corresponding to numerator taken with a minus sign.\n\
jComplexity[\!\(\*
StyleBox[\"j1\", \"TI\"]\),\!\(\*
StyleBox[\"j2\", \"TI\"]\)] is a shortcut for Expand[jComplexity@j1-jComplexity@j2].";


SetAttributes[jComplexity,Listable];


jComplexity[j[nm_,n__]]:=Module[{jsec=jSector@nm,jsec1},
If[Head[jsec]=!=js,Message[jSector::jtop,nm];Abort[]];
{jsec1,jsec}=Transpose[Replace[Transpose[{{n},Rest[List@@jsec]}],{x_Integer,_}:>{x,Boole[Positive[x]]},{1}]];
(*added 19.07.2014*){jsec1,jsec}={permute[jsec1,jsOrder[nm,##]&@@jsec],permute[jsec,jsOrder[nm,##]&@@jsec]};
Return[{nm,Length@#2,Plus@@#2-Plus@@#1,-(Plus@@#1)(*,-Plus@@#1,Plus@@#2*),FromDigits[jsec,2],Sequence@@-#2,Sequence@@#1}&[Pick[jsec1,jsec,0],Pick[jsec1,jsec,1]]]
]


jComplexity[j1_j,j2_j]:=Expand[jComplexity@j1-jComplexity@j2]


j/:j[nm1_,inds1__]<j[nm2_,inds2__]:=Module[{jc=jComplexity[j[nm1,inds1],j[nm2,inds2]],jc0},jc0=0&/@jc;
Return[(jc=!=jc0)&&MatchQ[jc,{__Integer}]&&OrderedQ[{jc,jc0}]]]
j/:j[nm1_,inds1__]>j[nm2_,inds2__]:=Module[{jc=jComplexity[j[nm1,inds1],j[nm2,inds2]],jc0},jc0=0&/@jc;
Return[(jc=!=jc0)&&MatchQ[jc,{__Integer}]&&OrderedQ[{jc0,jc}]]]
j/:j[nm1_,inds1__]<=j[nm2_,inds2__]:=Module[{jc=jComplexity[j[nm1,inds1],j[nm2,inds2]],jc0},jc0=0&/@jc;
Return[MatchQ[jc,{__Integer}]&&OrderedQ[{jc,jc0}]]]
j/:j[nm1_,inds1__]>=j[nm2_,inds2__]:=Module[{jc=jComplexity[j[nm1,inds1],j[nm2,inds2]],jc0},jc0=0&/@jc;
Return[MatchQ[jc,{__Integer}]&&OrderedQ[{jc0,jc}]]]


jVars::usage="jVars[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gives all j[\[Ellipsis]] of \!\(\*
StyleBox[\"expr\", \"TI\"]\) in the order from simplest to the most complex.";


jVars[expr_]:=Sort[DeleteDuplicates[Cases[{expr},_j,\[Infinity]]],Less];
jVars[expr_,jsec_js]:=Sort[Union[Cases[{expr},_j?(MatchQ[jSector[#],jsec]&),\[Infinity]]],Less];


Highj::usage="Highj[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gives the most complex j[\[Ellipsis]] of \!\(\*
StyleBox[\"expr\", \"TI\"]\). If there are no j[\[Ellipsis]] in \!\(\*
StyleBox[\"expr\", \"TI\"]\) then Highj[\!\(\*
StyleBox[\"expr\", \"TI\"]\)]\[Rule]{}.\n\
Essentially, it gives the same result as Last[jVars[\!\(\*
StyleBox[\"expr\", \"TI\"]\)]] but does it faster.";


Highjs::usage="Highjs[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gives the list of the most complex j[\[Ellipsis]] of \!\(\*
StyleBox[\"expr\", \"TI\"]\).";


Highj[expr_]:=Module[{jv,jvars=Union[Cases[{expr},_j,\[Infinity]]],jc0,jc,jc1},
If[jvars==={},{},
jv=First@jvars;jc=jComplexity@jv;
jc0=ConstantArray[0,Length@jc];
Scan[If[OrderedQ[{Expand[jc-(jc1=jComplexity@#)],jc0}],jv=#;jc=jc1]&,Rest@jvars];
jv
]]


Highjs[expr_]:=Module[{jv,jvars=DeleteDuplicates[Cases[{expr},_j,\[Infinity]]],jc0,jc,jc1},
If[jvars==={},{},
jv={First@jvars};jc=Take[jComplexity@First@jv,3];
jc0=ConstantArray[0,Length@jc];
Scan[(jc1=Take[jComplexity@#,3];Which[jc1===jc,AppendTo[jv,#],OrderedQ[{Expand[jc-jc1],jc0}],jv={#};jc=jc1])&,Rest@jvars];
jv
]]


HighjIndex::usage="HighjIndex[{j[\[Ellipsis]],j[\[Ellipsis]]\[Ellipsis]}] gives the index of the most complex j[\[Ellipsis]] in the list. If the list is empty it returns zero.\n\
Since this function is designed to be as fast as possible, there is no fool proof, so the proper argument is your responsibility.";


HighjIndex[jvars_List]:=Module[{ji,jc0,jc,jc1},
If[jvars==={},0,
ji=1;jc=jComplexity@First@jvars;
jc0=ConstantArray[0,Length@jc];
MapIndexed[If[OrderedQ[{Expand[jc-(jc1=jComplexity@#)],jc0}],ji=1+First@#2;jc=jc1]&,Rest@jvars];
ji
]];


js::usage="js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),1,0,\[Ellipsis]] denotes a sector. You can use comparisons <,>,\[LessEqual],\[GreaterEqual] between two sectors."
jSector::usage="jSector[j[basis,\[Ellipsis]]] gives the sector of the integral, that is, the object of the form js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),1,0,\[Ellipsis]] \
with 1 denoting the presence of the corresponding denominator.\n\
jSector[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a 'default' sector of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) used to resolve the sign of symbolic indices.";


jSector::jtop="jSector[`1`] is not defined.";


jSector[nm_]:=js[nm,##]&@@ConstantArray[1,Length@Ds@nm];


jSector[j[nm_,\[Alpha]__]]:=js@@Replace[Transpose[{{nm,\[Alpha]},List@@jSector@nm}],{{x_Integer,_}:>UnitStep[x-1/2],{_,x:(0|1)}:>x,_:>nm},{1}];


js/:Less[js[nm1_,x1:(0|1)...],js[nm2_,x2:(0|1)...]]:=nm1===nm2&&jsectlt[{x1}-{x2}];
js/:LessEqual[js[nm1_,x1:(0|1)...],js[nm2_,x2:(0|1)...]]:=nm1===nm2&&jsectle[{x1}-{x2}];
js/:Greater[js[nm1_,x1:(0|1)...],js[nm2_,x2:(0|1)...]]:=nm1===nm2&&jsectgt[{x1}-{x2}];
js/:GreaterEqual[js[nm1_,x1:(0|1)...],js[nm2_,x2:(0|1)...]]:=nm1===nm2&&jsectge[{x1}-{x2}];


GenerateIBP::usage="GenerateIBP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] generates IBP and LI identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
IBP::usage="IBP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the IBP (integration-by-part) identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
LI::usage="LI[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the LI(Lorentz invariance) identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
IBPLI::usage="IBPLI[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the IBP&LI identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";


GenerateIBP[nm_]:=Module[{ds=LFDistribute[Ds@nm,sp],dim=Length[Ds@nm],lms=LMs@nm,ems=EMs@nm,le=Length@EMs@nm,qms,dp,ibps,lis},
If[!ValueQ[Ds@nm],Message[NewBasis::notb];Return[$Failed]];
qms=Join[lms,ems];dp=Table[Unique["n"],{dim}];
ibps=Outer[Function[{qm,lm},
Collectj[Expand[(j[nm,##1]&)@@dp (Boole[qm===lm]MetricTensor[]-Plus@@MapIndexed[
Function[{den,ind},dp[[First[ind]]] (j[nm,##1]&@@IntegerDigits[2^(dim-First[ind]),2,dim])*Plus@@(2^Boole[#1===lm] sp[qm,#1] Coefficient[den,sp[lm,#1]]&)/@qms/. Toj[nm]],ds])],Factor]],
qms,lms];
lis=Plus@@MapIndexed[(#1/.{j[nm,x__]:>(ibps[[Range[-Length@ems,-1],First@#2]]/.Thread[dp->dp+{x}])})&,Expand[(j[nm,##]&@@ConstantArray[0,{dim}])Outer[sp,lms,ems]/.Toj[nm]]];
lis=Collectj[(lis[[##]]&@@Reverse[#])-(lis[[##]]&@@#),Factor]&/@Subsets[Range[Length@ems],{2}];
IBP[nm]^=Function[Evaluate@Flatten[ibps]]/.Thread[dp->Table[Slot[i],{i,dim}]];
LI[nm]^=Function[Evaluate@lis]/.Thread[dp->Table[Slot[i],{i,dim}]];
Remove/@dp;
LiteRedPrint["Integration-By-Part&Lorentz-Invariance identities are generated.\n\
    IBP[" <> # <>"] \[LongDash] integration-by-part identities,\n\
    LI[" <> # <>"] \[LongDash] Lorentz invariance identities."] &@ToString[nm];
]


IBP[nm_,inds__]:=IBP[nm][inds];
LI[nm_,inds__]:=LI[nm][inds];


IBPLI[nm_]/;ValueQ[IBP[nm]]&&ValueQ[LI[nm]]:=Function@@{Join[First@IBP@nm,First@LI@nm]};
IBPLI[nm_,inds__]:=IBPLI[nm][inds];


ToAB::usage="ToAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\),j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]]] gives the \!\(\*
StyleBox[\"AB\", \"TI\"]\)-form of \!\(\*
StyleBox[\"expr\", \"TI\"]\).\nToAB[\*
StyleBox[\(\!\(\*
StyleBox[\"expr_\", \"TI\"]\)Function\)],\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is a shortcut for ToAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\)[n1,n2,\[Ellipsis]],j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]]].\nToAB threads through lists in \!\(\*
StyleBox[\"expr\", \"TI\"]\).";
A::usage=B::usage="A and B are reserved names for the corresponding operators. They appear in the output of ToAB, see ?ToAB.";
AtoLeft::usage="AtoLeft[expr] pull all A operators to the left";


FromAB::usage="FromAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the Function-form of \!\(\*
StyleBox[\"expr\", \"TI\"]\).\nFromAB[\*
StyleBox[\(\!\(\*
StyleBox[\"expr_\", \"TI\"]\)Function\)],j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]]] is a shortcut for FromAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)][n1,n2,\[Ellipsis]].\nFromAB threads through lists in \!\(\*
StyleBox[\"expr\", \"TI\"]\).";


Protect[A,B];


Module[{jj},
ToAB[expr_Function,nm_]:=ToAB[expr[##],j[nm,##]]&@@Table[Unique["n"],{Length@Ds[nm]}];
ToAB[expr_List,jj_j]:=ToAB[#,jj]&/@expr;
ToAB[expr_,j[nm_,indices__]]:=toab[expr/.j[nm,inds__]:>jj[inds],jj,{indices}];
ToAB[expr_,jj_,indices_List]:=toab[expr,jj,indices];
];


AtoLeft[expr_]:=Collect[expr/.{HoldPattern[SmallCircle[ex:Subscript[(A|B), _]...]]:>atoleft[ex]},_SmallCircle];


FromAB[expr_,j[nm_,indices__]]:=FromAB[expr,nm][indices];
FromAB[expr_List,nm_]:=Function@@{First[FromAB[#,nm]]&/@expr};
FromAB[expr_,nm_]:=Module[{dots,form,n=Length@Ds[nm],slots},
slots=Table[Unique[],{n}];
form=Plus@@(#1(ablisttoexpr[#2,j[nm,##]&,slots])&@@@ablistform[expr]);
Function@@({form}/.Thread[slots->Slot/@Range[n]])
]


ablistform[expr_]:=Module[{form,dots,x,sc},
form=expr/.op:Subscript[(A|B), _]:>SmallCircle[op]/.SmallCircle->sc;
dots=DeleteDuplicates@Cases[{form},_sc,\[Infinity]];
form=Flatten[{#/.Thread[#2->0],Coefficient[#,#2]}&[form,dots]];
Transpose[{form,Prepend[List@@@dots,{}]}]
]


toab[recurr_,f_,ns_]:=Module[{ABs,As,Bs,rec,fs,nshifts,form,qrf,qr},
(*Insert foolproof later*)
ABs=Array[Subscript[AB, #]&,Length@ns];
As=Array[Subscript[A, #]&,Length@ns];
Bs=Array[Subscript[B, #]&,Length@ns];
rec=Collect[recurr,_f];(*to account for possible cancellations*)
fs=List@@@DeleteDuplicates@Cases[{rec},f@@(ns+_.),\[Infinity]];
nshifts=Max/@Transpose[(#-ns)&/@fs];(*indices shifts*)
(*Insert foolproof later*)
form=Plus@@((#2/.Thread[ns->ABs-nshifts])*Times@@(Bs^(ns+nshifts-First[Pick[fs,#1,1]]))&@@@CoefficientRules[rec,f@@@fs]);
(*Now we have to factor Bs from the left.*)
qrf[p_,i_]:={Factor[(p-(p/.Subscript[B, i]->0)/.Subscript[AB, i]->Subscript[AB, i]+1)/Subscript[B, i]+Subscript[A, i]*((p/.Subscript[B, i]->0)-(p/.Subscript[B, i]->0/.Subscript[AB, i]->1))/(Subscript[AB, i]-1)],Factor[(p/.Subscript[B, i]->0/.Subscript[AB, i]->1)]};
Do[(*Divide by B if possible*)
While[MatchQ[qr=qrf[form,i],{_,0}],form=First@qr],
{i,Length@Bs}];
Plus@@((#2*SmallCircle@@DeleteCases[Flatten@MapIndexed[MapThread[ConstantArray,{{Subscript[A, First[#2]],SmallCircle[Subscript[A, First[#2]],Subscript[B, First[#2]]],Subscript[B, First[#2]]},#1}]&,Partition[#1,3],1],1])&@@@CoefficientRules[form,Flatten@Transpose@{As,ABs,Bs}])/.sc_SmallCircle/;Length[sc]<2:>Times@@sc
]


atoleft[ex__]:=Module[{inds,Apos,Bnum,rule,form,As,Bs},
inds=DeleteDuplicates[{ex}[[All,2]]];
As=Subscript[A, #]&/@inds;Bs=Subscript[B, #]&/@inds;
Apos=ConstantArray[{},Length@inds];Bnum=ConstantArray[0,Length@inds];
rule=Flatten[MapIndexed[{Subscript[A, #]:>AppendTo[Apos[[First@#2]],Bnum[[First@#2]]],Subscript[B, #]:>++Bnum[[First@#2]]}&,inds]];
Replace[{ex},rule,{1}];
form=Times@@Table[Sum[Plus@@(Times@@(Range[0,i-1]-#)&/@Subsets[Apos[[n]],{i}])*Times@@Join[ConstantArray[As[[n]],Length@Apos[[n]]-i],ConstantArray[Bs[[n]],Bnum[[n]]-i]],{i,0,Min[Length@Apos[[n]],Bnum[[n]]]}],{n,Length@Apos}];
Plus@@((#2*Sort[SmallCircle@@DeleteCases[Flatten@MapIndexed[MapThread[ConstantArray,{{As[[First@#2]],Bs[[First@#2]]},#1}]&,Partition[#1,2],1],1]])&@@@CoefficientRules[form,Flatten@Transpose@{As,Bs}])/.sc_SmallCircle/;Length[sc]<2:>Times@@sc
]


ablisttoexpr[{ex___},jj_,indices_]:=Module[{sh,arg,rule,n=Length@indices},
sh=ConstantArray[{},n];arg=ConstantArray[0,n];
Replace[{ex},{Subscript[A, i_]:>AppendTo[sh[[i]],arg[[i]]++],Subscript[B, i_]:>--arg[[i]]},{1}];
Times@@Times@@@(indices+#1)(jj[##]&@@(#2+indices))&@@{sh,arg}
]


TildeConjugate::usage="TildeConjugate[\!\(\*
StyleBox[\"ABoperator\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives \[CapitalGamma][(L+1)d/2-\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)-b]\[SmallCircle]\!\(\*
StyleBox[\"ABoperator\", \"TI\"]\)\[SmallCircle](\[CapitalGamma][(L+1)d/2-\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)]\!\(\*SuperscriptBox[\()\), \(-1\)]\), where L is loop number of \!\(\*
StyleBox[\"basis\", \"TI\"]\), \*
StyleBox[\(\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)\)]\!\(\*
StyleBox[\" \", \"TI\"]\)is the sum over all Ds of the \!\(\*
StyleBox[\"basis\", \"TI\"]\), and b is maximal integer number, for which the result is polynomial in \!\(\*
StyleBox[\"A\", \"TI\"]\) and \!\(\*
StyleBox[\"B\", \"TI\"]\).";


TildeConjugate[expr_List,nm_]:=TildeConjugate[#,nm]&/@expr;
TildeConjugate[expr_,nm_]:=Module[{a,b,t,ph},
t={Subtract@@#1,#2}&@@@CoefficientRules[LFDistribute[expr/.{o:Subscript[A, _]:>a o,o:Subscript[B, _]:>b o},SmallCircle],{a,b}];
b=Min[First/@t];a=(Length@LMs@nm+1)*MetricTensor[]/2-Sum[SmallCircle[Subscript[A, i],Subscript[B, i]],{i,Length@Ds@nm}];
ph[o_,k_Integer?NonNegative]:=SmallCircle@@(o-1+Range[k]);
LFDistribute[Plus@@(SmallCircle[#2,ph[a,#1-b]]&@@@t),SmallCircle]
]


InverseTildeConjugate::usage="TildeConjugate[\!\(\*
StyleBox[\"ABoperator\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives (\[CapitalGamma][(L+1)d/2-\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)-b]\!\(\*SuperscriptBox[\()\), \(-1\)]\)\[SmallCircle]\!\(\*
StyleBox[\"ABoperator\", \"TI\"]\)\[SmallCircle](\[CapitalGamma][(L+1)d/2-\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)]), where L is loop number of \!\(\*
StyleBox[\"basis\", \"TI\"]\), \[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)is the sum over all Ds of the \!\(\*
StyleBox[\"basis\", \"TI\"]\), and b is minimal integer number, for which the result is polynomial in \!\(\*
StyleBox[\"A\", \"TI\"]\) and \!\(\*
StyleBox[\"B\", \"TI\"]\).\nNote that InverseTildeConjugate is not literally inverse of TildeConjugate, but that, multiplied from the left by inversible operator.";


InverseTildeConjugate[expr_List,nm_]:=InverseTildeConjugate[#,nm]&/@expr;
InverseTildeConjugate[expr_,nm_]:=Module[{a,b,t,ph},
t={Subtract@@#1,#2}&@@@CoefficientRules[LFDistribute[expr/.{o:Subscript[A, _]:>a o,o:Subscript[B, _]:>b o},SmallCircle],{a,b}];
b=Max[First/@t];a=(Length@LMs@nm+1)*MetricTensor[]/2-Sum[SmallCircle[Subscript[A, i],Subscript[B, i]],{i,Length@Ds@nm}];
ph[o_,k_Integer?NonNegative]:=SmallCircle@@(o-1+Range[k]);
LFDistribute[Plus@@(SmallCircle[#2,ph[a+#1-b,b-#1]]&@@@t),SmallCircle]
]


ABIBP::usage="ABIBP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the AB-form of the IBP identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
ABLI::usage="ABLI[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the AB-form of the LI identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
ABIBPLI::usage="ABIBPLI[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the AB-form of the IBP&LI identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";


ABIBP[nm_]/;ValueQ[IBP@nm]:=(ABIBP[nm]^=ToAB[IBP@nm,nm]);
ABLI[nm_]/;ValueQ[LI@nm]:=(ABLI[nm]^=ToAB[LI@nm,nm]);
ABIBPLI[nm_]/;ValueQ[ABIBP@nm]&&ValueQ[ABLI@nm]:=Join[ABIBP@nm,ABLI@nm];


SubstituteAlways::usage="SubstituteAlways\[Rule]True is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\!\(\*
StyleBox[\"database\", \"TI\"]\)] which forces exhaustive substitutions.";
SimplifyAlways::usage="SimplifyAlways\[Rule]True|False is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\[Ellipsis]] which determines whether a singe terms  should be simplified.";
SimplifyFunction::usage="SimplifyFunction\[Rule]Function[\[Ellipsis]] is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\[Ellipsis]] which determines the function to be used for the simplification of the terms.";
CheckZeroAlways::usage="CheckZeroAlways\[Rule]True|False is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\[Ellipsis]] which determines whether a singe leading term  should be simplified.";
CheckZeroFunction::usage="CheckZeroFunction\[Rule]Function[\[Ellipsis]] is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\[Ellipsis]] which determines the function to be used for the simplification of a leading term.";



Solvej::usage="Solvej[\!\(\*
StyleBox[\"eq\", \"TI\"]\)] solves equation \!\(\*
StyleBox[\"eq\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\) with respect to the most complex j[\[Ellipsis]],\n\
Solvej[\!\(\*
StyleBox[\"eq\", \"TI\"]\),\!\(\*
StyleBox[\"database\", \"TI\"]\)] first applies rules \!\(\*
StyleBox[\"database\", \"TI\"]\) to \!\(\*
StyleBox[\"eq\", \"TI\"]\) and then solves it with respect to the most complex j[\[Ellipsis]]. The new rule is appended to \!\(\*
StyleBox[\"database\", \"TI\"]\).\n\
Valid options include:\n\
    SimplifyAlways\[Rule]True|False:True determines whether singe terms should be simplified,\n\
    SimplifyFunction\[Rule]Function[\[Ellipsis]]:Factor1 function used for the simplification,\n\
    CheckZeroAlways\[Rule]True|False:True determines whether a singe leading term  should be simplified,\n\
    CheckZeroFunction\[Rule]Function[\[Ellipsis]]:Factor1 function used for the simplification of a leading term,\n\
    SubstituteAlways\[Rule]True|False:False determines whether a new rule should be applied to database.";
Solvej::freeterm="Free term detected: `1`";
Solvej::nosol="Equation `1`==0 has no solutions.";


SetAttributes[Solvej,{HoldRest}];
Options[Solvej]={SubstituteAlways->False,SimplifyAlways->True,SimplifyFunction->Factor1,CheckZeroAlways->True,CheckZeroFunction->Factor1};


Solvej[eq_,OptionsPattern[]]:=Module[{
sf,czf,sa,cza,czf1,sf1,
fterm,lst,j1,j2,c,fterm1},
{sf,czf,sa,cza}={OptionValue[SimplifyFunction],OptionValue[CheckZeroFunction],OptionValue[SimplifyAlways],OptionValue[CheckZeroAlways]};
czf1=If[cza,("czf"[Plus@@#]&),(If[Length@#>1,"czf"[Plus@@#],Plus@@#]&)]/.{"czf"->czf};sf1=If[sa,("sf"[Plus@@#]&),(If[Length@#>1,"sf"[Plus@@#],Plus@@#]&)]/.{"sf"->sf};
{fterm,lst}=Reap[csow[eq/.Times->times,1],_,{#1,#2}&]/.times->Times;
fterm=sf[fterm];
While[True,
If[lst==={},If[fterm=!=0,Message[Solvej::nosol,fterm]];Return[False->False]];
lst=MapAt[(c=czf1[#])&,RotateLeft[lst,HighjIndex[First/@lst]],{-1,-1}];
 If[c===0,lst=Most@lst,Break[]];
];
j1=First@Last@lst;
If[fterm=!=0,Message[Solvej::freeterm,fterm]];
j1->-(c)^(-1)*(Plus@@Times@@@({#1,sf1[#2]}&@@@Most[lst])+fterm)];


Solvej[eq_,db_,opts:OptionsPattern[]]:=
Module[{
j1,j2,c,lst,fterm,fterm1,l1,sr,f,jdb,rule,
sf,czf,sa,cza,
czf1,sf1
},
{sf,czf,sa,cza}={OptionValue[SimplifyFunction],OptionValue[CheckZeroFunction],OptionValue[SimplifyAlways],OptionValue[CheckZeroAlways]};
czf1=If[cza,("czf"[Plus@@#]&),(If[Length@#>1,"czf"[Plus@@#],Plus@@#]&)]/.{"czf"->czf};
sf1=If[sa,("sf"[Plus@@#]&),(If[Length@#>1,"sf"[Plus@@#],Plus@@#]&)]/.{"sf"->sf};
jdb=Dispatch[db];
If[OptionValue[SubstituteAlways],
rule=Solvej[eq//.jdb,opts];
If[rule===$Failed,Return[False]];
sr=(#1:>(f:=(f=Identity;Collectj[#,SimplifyAlways->sa,SimplifyFunction->sf])&;#2))&@@rule;f=Identity;
db=Prepend[(r=#/.sr;f[r])&/@db,rule];True,
(*SubstituteAlways=False*)
(*j1:=First@Last@lst;*)
{fterm,lst}=Reap[csow[eq/.Times->times,1],_,{#1,#2}&]/.times->Times;fterm=sf[fterm];
While[True,
If[lst==={},If[fterm=!=0,Message[Solvej::nosol,fterm]];Return[False]];
lst=MapAt[(c=czf1[#])&,RotateLeft[lst,HighjIndex[First/@lst]],{-1,-1}];
 If[c===0,lst=Most@lst;Continue[]];
j1=First@Last@lst;
If[j1===(j2=Replace[j1,jdb]),Break[]];
{fterm1,lst}=Reap[Sow@@@Reverse/@Most[lst/.Times->times];csow[j2/.Times->times,c],_,{#1,Flatten@#2}&]/.times->Times;fterm=sf[fterm+fterm1];
];
If[fterm=!=0,Message[Solvej::freeterm,fterm]];
PrependTo[db,j1->-(c)^(-1)*(Plus@@Times@@@({#1,sf1[#2]}&@@@Most[lst])+fterm)];True
]
]


SolvejSector::usage="SolvejSector[\!\(\*
StyleBox[\"sector\", \"TI\"]\):js[\[Ellipsis]]] tries to find symbolic rules for the reduction of the integrals in the \!\(\*
StyleBox[\"sector\", \"TI\"]\).\n\
Options:\n\
    NamingFunction\[Rule]Function[\[Ellipsis]]|Automatic:Automatic, see ?NamingFunction;\n\
    Depth\[Rule]_Integer:2, the Depth of the heuristic search. If the search did not succeeded in reducing the sector to a finite number of integrals, search depth is incereased automatically;\n\
    NMIs\[Rule]n:0, expected number of master integrals. If the number of the integrals left is less or equal to n, the program terminates assuming those integrals are masters, which may save some time.\n\
    MIs\[Rule]{\[Ellipsis]}:{}, expected masters in the sector.\n\ 
    SR\[Rule]False|True:True determines whether the symmetry relations should be used on the last step;\n\
    DiskSave\[Rule]True|False|\!\(\*
StyleBox[\"directory\", \"TI\"]\):False determines whether to save the found rules on the disk.";
SolvejSector::leak="Discrepancy detected. Reduction is not full: `1`.";
NMIs::usage="NMIs\[Rule]n is an option for SolvejSector, which determines the minimal number of masters in the sector.";


Options[SolvejSector]={NamingFunction->Automatic,
Depth->2(*\:0433\:043b\:0443\:0431\:0438\:043d\:0430 \:043f\:043e\:0438\:0441\:043a\:0430*),
SR->True(*\:0438\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:0442\:044c \:0441\:043e\:043e\:0442\:043d\:043e\:0448\:0435\:043d\:0438\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438?*),
NMIs->0,
MIs->{},
(*UseRules\[Rule]False,*)
DiskSave->True(*\:0421\:043e\:0445\:0440\:0430\:043d\:044f\:0442\:044c \:043d\:0430\:0439\:0434\:0435\:043d\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:043d\:0430 \:0434\:0438\:0441\:043a\:0435?*),
DiskRecover->False,
Replace->True,
TimeConstrained->False,
CheckZeroFunction->Factor1,
CheckZeroAlways->True,
SimplifyFunction->Factor1,
SimplifyAlways->True,
SubstituteAlways->False
};
SolvejSector::parse="Could not parse `1`.";
SolvejSector::dim="Please, set dimension to be a symbol. Use SetDim[\[Ellipsis]]. Aborting...";


SolvejSector[nm_Symbol,opts:OptionsPattern[]]:=SolvejSector[UniqueSectors[nm],opts];
SolvejSector[sects_List,opts:OptionsPattern[]]:=SolvejSector[#,opts]&/@sects


SolvejSector[sect_js,OptionsPattern[]]:=Module[{(*debug,*)sec=List@@Rest@sect,dim=Length@sect-1,rsrvd=False,inds,scond,ne=0,ne1=0,sign,ptl={},mis={},nmis,nm=First@sect,numi,secS=ToString[HoldForm[jRules[##]]&@@sect],NoRules={{}},nrordrd,FoundRules={},params,d=MetricTensor[],ids,rules1,rules2,startp,pat1,ptrnrule,jRules1,jRulesF,jRulesDB,pos,searchDepth,useSR,recover,continue,mir,nr,fr,tcnd,ds,dr,omis,onmis,tc,tcf,sjopts,whenBad,smartReduce,smartReduce1,eqr,cf,fromRules,expandRules,found,depth},
CheckAbort[(**)(*nums1=First/@Flatten[SplitCases[Transpose[{Range[dim],sec}],{{_,0}}],1];*)(*\:0412\:044b\:0447\:0438\:0441\:043b\:044f\:0435\:043c \:043e\:043f\:0446\:0438\:0438*){inds,searchDepth,useSR,ds,dr,omis,onmis,tc}={Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][dim],OptionValue@Depth,OptionValue@SR,Replace[OptionValue@DiskSave,True:>BasisDirectory[nm]],Replace[OptionValue@DiskRecover,{Automatic|True->True,_->False}],OptionValue@MIs,OptionValue@NMIs,OptionValue@TimeConstrained};Declare[Evaluate@inds,Number];(*inds\[LongDash]\:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:044b\:0435 \:0434\:043b\:044f \:0438\:043d\:0434\:0435\:043a\:0441\:043e\:0432*)tcf=If[Not@TrueQ@Not@tc,TimeConstrained,#&];sjopts=FilterRules[(#->OptionValue[SolvejSector,#])&/@First/@Options[SolvejSector],Options[Solvej]];onmis=Replace[onmis,{Automatic:>If[MemberQ[$ContextPath,"Mint`"],If[IntegerQ[#],#,0]&@Symbol["CountMIs"][sect,Symmetric->useSR],0]}];(*Recovering from disk*)
scond=Inner[#2[#1]&,inds,(sec/.{1->(GreaterEqual[#,1]&),0->(LessEqual[#,0]&)}),List];ptrnrule=Inner[#1->Pattern[#1,_]?#2&,inds,(sec/.{1->Positive,0->NonPositive}),List];
If[Not@TrueQ@Not@ds&&dr&&FileExistsQ[ds<>"/"<>secS],jRulesF=Get[ds<>"/"<>secS];If[jRulesF==="reserved",LiteRedPrint["The sector ",sect," is likely being solved by another kernel. Execute SolvejSector["<>ToString[sect]<>",DiskRecover\[Rule]True] later to update MIs["<>ToString[nm]<>"]."];,mis=j[nm,##]&@@inds/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@jRulesF[[All,1,2]]]&&(And@@scond),Integers]]};If[!FreeQ[mis,Alternatives@@inds],Message[SolvejSector::leak,mis]]];If[ds===BasisDirectory[nm],ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>\"/"<>secS<>"\"]"],ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[\""<>ds<>"/"<>secS<>"\"]"]];LiteRedPrint["Sector ",sect," is recovered from file"];,(**)tcf[LiteRedPrint["Sector ",sect];If[Not[TrueQ@Not@ds||FileExistsQ[ds<>"/"<>secS]],If[!DirectoryQ[ds],CreateDirectory[ds];Message[DiskSave::dir,ds]];Put["reserved",ds<>"/"<>secS];rsrvd=True];(*ptrnrule\[LongDash]\:0437\:0430\:043c\:0435\:043d\:0430 inds \:043d\:0430 \:043f\:0430\:0442\:0442\:0435\:0440\:043d\:044b*)(*nrordrd=Which[Length[#1]<Length[#2],True,Length[#1]>Length[#2],False,LessEqual@@((j[nm,##]&@@inds)/.{#2,#1}),True,True,False]&;*)
(*nrordrd[x_]:=Sort[x,Which[0=!=(tcnd=Length@#1-Length@#2),tcnd<0,0=!=(tcnd=Count[Pick[inds/.#1,sec,0],_Integer]-Count[Pick[inds/.#2,sec,0],_Integer]),
tcnd<0,True,(j[nm,##]&@@inds/.#1)>(j[nm,##]&@@inds/.#2)
]&];*)nrordrd[x_]:=First/@Flatten[Sort[#,(Last@#1)>(Last@#2)&]&/@SortBy[Gather[{#,j[nm,##]&@@inds/.#}&/@x(*\:0421\:0430\:043c\:0438 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0438 \:0438\:043d\:0434\:0435\:043a\:0441\:044b \:043f\:043e\:0441\:043b\:0435 \:0438\:0445 \:043f\:0440\:0438\:043c\:0435\:043d\:0435\:043d\:0438\:044f*),MatchQ[Expand[List@@Last@#1-List@@Last@#2],{__Integer}]&(*\:0421\:043e\:0431\:0438\:0440\:0430\:0435\:043c \:0432 \:0433\:0440\:0443\:043f\:043f\:044b \:0440\:043e\:0434\:0441\:0442\:0432\:0435\:043d\:043d\:044b\:0445*)],{
Length@First@First@#,(*# of fixed parameters*)
Count[Last@First@#,_Integer],(*# of numeric indices*)
Sort@Flatten@Position[Take[jComplexity[Last@First@#],-dim],Except[_Integer],{1}]
(*position of symbolic indices*)
}&],1];
(*\:0414\:0443\:0440\:0430\:043a\:043e\:0437\:0430\:0449\:0438\:0442\:0430*)(*If[NumericQ[d]||!MatchQ[d,_Symbol],Message[SolvejSector::dim];Abort[]]*);(*\:0434\:043e\:043f\:0438\:0441\:0430\:0442\:044c \:043f\:043e\:0442\:043e\:043c*)(*\:0441\:0432\:043e\:0431\:043e\:0434\:043d\:044b\:0435 \:043f\:0430\:0440\:0430\:043c\:0435\:0442\:0440\:044b*)params=Select[Variables[{d,Outer[sp,EMs@nm,EMs@nm],LFDistribute@Ds@nm}],FreeQ[#,Alternatives@@LMs@nm]&];AppendTo[ptl,LiteRedPrintTemporary["Parameters "<>ToString[params]<>" are assumed to be independent."]];(*\:0413\:043e\:0442\:043e\:0432\:0438\:043c\:0441\:044f \:043a \:0440\:0435\:0448\:0435\:043d\:0438\:044e \:0443\:0440\:0430\:0432\:043d\:0435\:043d\:0438\:0439 \:0432 \:0434\:0430\:043d\:043d\:043e\:043c \:0441\:0435\:043a\:0442\:043e\:0440\:0435*)jSector[nm]=sect;jRulesF={};(*ids="Function"[Join[First@IBP[nm],First@LI[nm]]]/."Function"\[Rule]Function;*)ids=Function@@{sharpen[Join[IBP[nm]@@inds,LI[nm]@@inds]]/.MapIndexed[#->Slot@@#2&,inds]};sign=(1-2IntegerDigits[#,2,dim])&/@Range[0,2^dim-1];(*whenBad*)whenBad[expr_]:=Module[{jl=Cases[CollectjList[expr],{_j,_}],dconds,nconds},dconds=LogicalExpand[Or@@(And@@Thread[0==Flatten[{CoefficientList[#,params]}]]&/@Union@@((First/@FactorList[#])&/@Denominator/@Last/@jl))];nconds={#2,smartReduce[Or@@Thread[Pick[List@@#1,sect,0]>=1]]}&@@@jl;If[MemberQ[nconds,{_,True}],Return[True]];nconds=Or@@Flatten@Cases[nconds,{b_,a:Except[False]}:>Cases[Replace[{a},Or->Sequence,{2},Heads->True],x_/;0=!=Expand[Numerator[b]/.ToRules[x]]]];(*LogicalExpand@*)smartReduce[LogicalExpand[dconds||nconds]]];(*/whenBad*)(*smartReduce*)smartReduce[expr_]:=Module[{exprl=Replace[{expr},Or->Sequence,{2},Heads->True],t,l},(*WriteString["stdout","<"];(WriteString["stdout",ToString[#]<>">\n"];#)&@*)(Or@@((t=Replace[{#},And->Sequence,{2},Heads->True];t=And@@(Function[l,cf[LogicalExpand@TimeConstrained[(*\[LeftArrow]added 25.12.2012*)Reduce[#,l[[1,2]],Integers],300,#]&[And@@l[[All,1]]&&(And@@Select[scond,MemberQ[l[[1,2]],First@#]&])]]]/@GatherBy[Transpose[{t,FixedPoint[Function[l,Union@@Cases[l,x_/;{}!=Intersection[#,x]]&/@l],Cases[inds,n_/;Not[FreeQ[#,n]]]&/@t]}],Last]))&/@exprl))];cf[x_Or]:=cf/@x;cf[x_]:=Module[{Cs=Union@Cases[{x},_C,\[Infinity]](*\:0441\:0433\:0435\:043d\:0435\:0440\:0438\:0440\:043e\:0432\:0430\:043d\:043d\:044b\:0435 Reduce \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*),l=Replace[{x},And->Sequence,{2},Heads->True],c,dens=Alternatives@@Pick[inds,sec,1],nums=Alternatives@@Pick[inds,sec,0]},If[MatchQ[x,True|False],Return[x]];l=Replace[l,(*\:0417\:0430\:043c\:0435\:043d\:044f\:0435\:043c \:043d\:0430 \:043a\:0430\:043d\:043e\:043d\:0438\:0447\:0435\:0441\:043a\:0443\:044e \:0444\:043e\:0440\:043c\:0443*)HoldPattern[y_Alternatives\[Element]Integers]:>Sequence@@((#\[Element]Integers)&/@List@@y),{1}];If[Cs=!={},(*\:0415\:0441\:0442\:044c \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)(*\:041f\:0440\:043e\:0432\:0435\:0440\:044f\:0435\:043c,\:0447\:0442\:043e Reduce \:0441\:0433\:0435\:043d\:0435\:0440\:0438\:043b \:0442\:043e\:043b\:044c\:043a\:043e \:0446\:0435\:043b\:044b\:0435 \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)If[And@@(MemberQ[l,HoldPattern[#\[Element]Integers]]&/@Cs),l=DeleteCases[l,Alternatives@@Cs\[Element]Integers],(*Message[SolvejSector::parse,eqr];*)Return[True]];c=Cases[l,(y_>=#)|(y_<=#)|(#<=y_)|(#>=y_)]&/@Cs;If[Not[And@@(Length[#]===1&/@c)],(*Message[SolvejSector::parse,eqr];*)Return[True]];c=Flatten@c;l=Complement[l,c];c=(*\:0417\:0434\:0435\:0441\:044c \:043d\:0435 \:0441\:043e\:0432\:0441\:0435\:043c \:043f\:043e\:043d\:044f\:043b*)Cases[l,t:((z:#+1)==(y:dens)|(y:dens)==(z:#+1)|(z:-#)==(y:nums)|(y:nums)==(z:-#)):>{y,t}]&/@MapThread[Replace[#1,{y_>=#2|#2<=y_:>Expand[y-#2],y_<=#2|#2>=y_:>Expand[#2-y]}]&,{c,Cs}];If[MemberQ[c,{}],(*Message[SolvejSector::parse,eqr];*)Return[True]];c=Last@Last@SortBy[#,Position[inds,First@#1,1]&]&/@c;l=Complement[l,c];c=ExpandAll[Flatten[Solve[c,Cs]]],c={}];(*\:041e\:0447\:0435\:0432\:0438\:0434\:043d\:044b\:0435 \:043e\:0433\:0440\:0430\:043d\:0438\:0447\:0435\:043d\:0438\:044f \:043d\:0430 \:0438\:043d\:0434\:0435\:043a\:0441\:044b \:0441\:0440\:0430\:0437\:0443 \:0443\:0434\:0430\:043b\:044f\:0435\:043c*)l=DeleteCases[l,Alternatives@@inds\[Element]Integers|dens>=1|1<=dens|nums<=0|0>=nums];(*\:0414\:043e\:043b\:0436\:043d\:044b \:043e\:0441\:0442\:0430\:0442\:044c\:0441\:044f \:0442\:043e\:043b\:044c\:043a\:043e \:0440\:0430\:0432\:0435\:043d\:0441\:0442\:0432\:0430*)If[!MatchQ[l,{(Alternatives@@inds==_|_==Alternatives@@inds)...}],(*Message[SolvejSector::parse,eqr];*)Return[True]];l=ExpandAll[Replace[l,(y_==(z:Alternatives@@inds))|((z:Alternatives@@inds)==y_):>z==(y/.c),{1}]];And@@l];(*/smartReduce*)(*fromRules*)fromRules[x_]:=Or@@And@@@(x/.Rule->Equal);(*/fromRules*)(*expandRules*)expandRules[x_]:=(Pick[#1,Table[!MemberQ[Delete[#2,i]/.#1[[i]],True],{i,Length[#1]}]]&[#,Apply[And,#/.Rule->Equal,{1}]])&[Union[Sort/@x]];(*/expandRules*)(* ********************************************************************************************************)(*First,solve identities in general case*)(*debugt=AbsoluteTime[];*)jRulesDB={};Solvej[ne++;#,jRulesDB,Evaluate[Sequence@@sjopts]]&/@(ids@@inds);(*Shift indices to cannonical form in the l.h.s.*)jRulesDB=(#/.MapThread[#1->Expand[2#1-#2]&,{inds,Rest[List@@First[#]]}])&/@jRulesDB;(*Patternize the left sides of the rules and form a list of rules for the integrals to consider later*){jRulesF,rules1}=Reap[(#[[1]]/.ptrnrule)/;"condition"->Collectj[#[[2]],Factor1]/."condition"->Not[Sow[whenBad[#[[2]]]]]&/@jRulesDB];(*Print["Time:",AbsoluteTime[]-debugt];*)(*Just for safety:do not expect empty list*)If[rules1==={},Print["Abnormality: rules have not been sown. Aborting...",Abort[]]];(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)(*NoRules=Sort[{ToRules[smartReduce[LogicalExpand[And@@First@rules1]]]},nrordrd];(*Now we enter the main loop*)*)NoRules=nrordrd[{ToRules[smartReduce[LogicalExpand[And@@First@rules1]]]}];jRulesF=DeleteCases[jRulesF,HoldPattern[x_Condition->_]/;Last[x]===False];(*Remove rules that never work*)nr=Length[jRulesF];(*Print[jRulesF];****debug****)
(*LOOP OVER NoRules*)
LiteRedMonitor[While[
NoRules=!={},
(*Consider first case*)
rules1=First@NoRules;NoRules=Rest@NoRules;
startp=inds/.rules1;numi=FreeQ[startp,Alternatives@@inds];
found=False;If[!numi||(!MemberQ[omis,j[nm,##]&@@startp]&&Length[mis]+Length[NoRules]>=onmis),(*\:0418\:043d\:043e\:0433\:0434\:0430 \:0431\:043e\:043b\:0435\:0435 \:0441\:043f\:0435\:0446\:0438\:0444\:0438\:0447\:0435\:0441\:043a\:0438\:0435 \:0441\:043b\:0443\:0447\:0430\:0438 \:043f\:043e\:043f\:0430\:0434\:0430\:044e\:0442 \:0432 \:0443\:0436\:0435 \:0440\:0435\:0448\:0435\:043d\:043d\:044b\:0435*)If[(fr=Select[FoundRules,TrueQ[First[#]/.rules1]&&Not[TrueQ[Simplify[Last[#]/.rules1]]]&,1])=!={},(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)NoRules=nrordrd[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[(*Rest@*)NoRules]||fromRules[{rules1}]&&fr[[1,2]]]]}]];Continue[]];nr++;pat1=(j[nm,##]&@@(Pattern[#,Blank[]]&/@inds))/;"condition"/."condition"->fromRules[{rules1}];pos=Flatten[
Position[inds,Alternatives@@Complement[inds,First/@rules1],1]];jRulesDB={};
depth=0;
While[depth<=searchDepth,
(ne++;((*Solve equations*)If[Solvej[#,jRulesDB,Evaluate[Sequence@@sjopts]],jRules1=First[jRulesDB];If[(numi&&First@jRules1<j[nm,##]&@@startp),jRulesDB=Rest[jRulesDB];(*Collect garbage when doing Laporta*),(*added 23.06.2014*)If[TrueQ[jSector@First@jRules1<jSector@j[nm,##]&@@startp],jRulesDB=Rest[jRulesDB];(*Useless rule*)(*later join*),
(*If found possible rule*)
If[MatchQ[First@jRules1,pat1],jRules1=(#/.MapThread[#1->Expand[2#1-#2]&,{inds[[pos]],Rest[List@@First[#]][[pos]]}])&[jRules1];(*Patternize the left sides of the rules and form a list of rules for the integrals to consider later*){jRules1,rules2}=Reap[(j[nm,##]&@@inds/.ptrnrule)/;"condition"->Collectj[#[[2]],Factor1]/."condition"->fromRules[{rules1}]&&Not[Sow[whenBad[#[[2]]]]]&@jRules1];(*Just for safety:do not expect empty list*)If[rules2==={},Print["Abnormality: rules have not been sown. Aborting...",Abort[]]];{rules2}=First@rules2;(*If found suitable rule*)If[rules2=!=True,(*Found the rule!*)
AppendTo[FoundRules,{fromRules[{rules1}],rules2}];(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)NoRules=nrordrd[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[NoRules]||fromRules[{rules1}]&&rules2]]}]];AppendTo[jRulesF,jRules1];found=True;
Break[]];]]]];)&/@(DeleteDuplicates@If[useSR&&numi,DeleteCases[Join[ids@@#,SR[nm]@@#],0],ids@@#]))&/@((ne1=ne+Length[#];#)&@((*\:0421\:043f\:0438\:0441\:043e\:043a \:0442\:043e\:0447\:0435\:043a \:0434\:043b\:044f \:043f\:043e\:0438\:0441\:043a\:0430*)(*\:0423\:0431\:043e\:0433\:0430\:044f \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0430,\:043f\:043e\:0442\:043e\:043c \:043f\:0435\:0440\:0435\:043f\:0438\:0441\:0430\:0442\:044c*)Sort[Cases[startp+#&/@Union@@Outer[Times,sign,layer[sec,depth,depth](*Join@@(Compositions[#,dim]&/@Range[0,searchDepth])*),1],x_/;(jSector[j[nm,##]&@@x]===sect)],Which[(*(tcnd=(Plus@@Abs[#1-startp]-Plus@@Abs[#2-startp]))\[NotEqual]0,tcnd<0,*)(tcnd=(Abs[Plus@@((2sec-1)(#1-startp))]-Abs[Plus@@((2sec-1)(#2-startp))]))!=0,tcnd<0,True,(j[nm,##]&@@(#1))<=(j[nm,##]&@@(#2))]&]));
If[++depth>searchDepth&&!numi,searchDepth=depth;AppendTo[ptl,LiteRedPrintTemporary["Increasing search depth to "<>ToString[searchDepth]]]]
];(************************************************************************************************************************************)(*];*)
(*If[!numi,AppendTo[ptl,LiteRedPrintTemporary["Increasing search depth to "<>ToString[++searchDepth]]];Throw[Null]]*)];
If[!found,
AppendTo[ptl,LiteRedPrintTemporary["Found master integral "<>ToString[startp]]];AppendTo[mis,j[nm,##]&@@startp]]
],TableForm[{Overlay[{ProgressIndicator[Count[inds,x_/;FreeQ[startp,x]],{0,Length@inds+1/2}],ToString[ne]<>"\[Rule]"<>ToString[ne1]},Alignment->Center],ToString[nr]<>" point: "<>ToString[startp]}]],tc,If[!numi,(*If[rsrvd,DeleteFile[ds<>"/"<>secS]];*)Return[$Failed],mis=j[nm,##]&@@inds/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@jRulesF[[All,1,2]]]&&(And@@scond),Integers]]};If[!FreeQ[mis,Alternatives@@inds],Message[SolvejSector::leak,mis]]]];If[TrueQ[Not[ds]],(#1/:jRules[##]=jRulesF),If[!DirectoryQ[ds],CreateDirectory[ds];Message[DiskSave::dir,ds]];If[!FileExistsQ[ds<>"/"<>secS]||OptionValue[Replace],If[!rsrvd&&FileExistsQ[ds<>"/"<>secS],Message[DiskSave::overwrite,ds<>"/"<>secS]];ReleaseHold[Hold[Put[##]]]&[jRulesF,ds<>"/"<>secS];If[ds===BasisDirectory[nm],ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>\"/"<>secS<>"\"]"],ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[\""<>ds<>"/"<>secS<>"\"]"]]]]&@@sect;fr=Reduce[Not[Or@@(And@@Thread[inds==Rest[List@@#]]&/@mis)||Or@@jRulesF[[All,1,2]]]&&(And@@scond),Integers];If[Not[TrueQ[Not[fr]]],Message[SolvejSector::leak,j[nm,##]&@@inds/.{ToRules[LogicalExpand@fr]}]];];MIs[nm]^=jVars[{DeleteCases[MIs[nm],_?(jSector[#]===sect&)],mis}];(*LiteRedPrint["    Master integrals found: "<>If[mis==={},"none",StringTrim[ToString[mis]," "|"{"|"}"]]<>".\n\    "<>ToString["jRules"@@sect]<>" \[LongDash] reduction rules for the sector.\n\    MIs["<>ToString[nm]<>"] \[LongDash] updated list of the masters."]*)
LiteRedPrint["    "<>ToString[Length@mis]<>" master integrals found"<>If[mis==={},"",":\n"<>StringTrim[ToString[mis]," "|"{"|"}"]]<>".\n    "<>ToString["jRules"@@sect]<>" \[LongDash] reduction rules for the sector.\n    MIs["<>ToString[nm]<>"] \[LongDash] updated list of the masters."];NotebookDelete/@ptl;If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];Length@mis,(*Cleaning up*)If[rsrvd,DeleteFile[ds<>"/"<>secS]];Abort[]]]


SolvejSector::nots="The first argument of SolvejSector should be js[\[Ellipsis]]. Received instead:\n`1`";


SolvejSector[sect_,OptionsPattern[]]:=(Message[SolvejSector::nots,sect];$Failed)


AnalyzeSectors::usage="AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] forms the lists of sectors:\n\
    ZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of zero sectors,\n\
    NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of nonzero sectors,\n\
    SimpleSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of simplest nonzero sectors, i.e. nonzero sectors with all subsectors being zero,\n\
    BasisSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of nonzero sectors with at least one zero immediate subsectors.\n\
AnalyzeSectors also generates the rule ZerojRule[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] which nullifies all zero integrals.\n\
AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"pattern\", \"TI\"]\)] analyzes only  sectors js[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"dens\", \"TI\"]\)] such that {\!\(\*
StyleBox[\"dens\", \"TI\"]\)} matches \!\(\*
StyleBox[\"pattern\", \"TI\"]\). \
This is useful if there are additional numerators in the diagram. E.g., if the first index of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) corresponds to the numerator, use AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\),{0,__}]. This will speed up the analysis.";
ZeroSectors::usage="ZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of zero sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).\n\
Note, that this list is formed by AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"pattern\", \"TI\"]\)] procedure. If \!\(\*
StyleBox[\"pattern\", \"TI\"]\) is issued, only those zero sectors which match \!\(\*
StyleBox[\"pattern\", \"TI\"]\) are listed.\n\
See also ?ZerojRule and ?AnalyzeSectors.";
NonZeroSectors::usage="NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of nonzero sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).\n\
Note, that this list is formed by AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"pattern\", \"TI\"]\)] procedure. If \!\(\*
StyleBox[\"pattern\", \"TI\"]\) is issued, only those zero sectors which match \!\(\*
StyleBox[\"pattern\", \"TI\"]\) are listed.\n\
See also ?ZerojRule and ?AnalyzeSectors.";
BasisSectors::usage="BasisSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of basis sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).\n\
	The sector from this set has at least one zero immediate subsector.";
SimpleSectors::usage="SimpleSectors[basis] is the list of the simplest nonzero sectors of the basis.\n\
	For each sector in this list all its subsectors are zero.";
ZerojRule::usage="ZerojRule[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the rule which nullifies all zero integrals.";
CutDs::usage="CutDs\[Rule]{1,0,\[Ellipsis]} is an option for AnalyzeSectors[nb,\[Ellipsis]], which determines, that denominators of the sector js[nb,1,0,\[Ellipsis]] are cut and thus all sectors without any of those denominators are zero.\nCutDs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a flag list of the cut denominators of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";


(*for backward compatibility *)
CutDs[nm_]:=ConstantArray[0,Length@Ds@nm]


AnalyzeSectors::noibp="No IBP relations found. Forgot to generate ones with GenerateIBP[`1`]?";


Options[AnalyzeSectors]={CutDs->None,FeynParUF->True};


AnalyzeSectors[nm_,opts:OptionsPattern[]]:=AnalyzeSectors[nm,_,opts];
AnalyzeSectors[nm_,patt_,OptionsPattern[]]:=Module[{nds=Length@Ds@nm,nloops=Length@LMs@nm,nsects,nsects1,sectors,zsectors,nzsectors={},ssectors={},bsectors={},dbase,s1,st,cds,chzf,feynpar,str,fp,x,xs},If[!ValueQ[Ds@nm]||!ValueQ[LMs@nm],Message[NewBasis::notb];Return[$Failed]];
If[!ValueQ[IBP@nm],Message[AnalyzeSectors::noibp,nm];Return[$Failed]];
nds=Length@Ds@nm;
cds=OptionValue[CutDs]/.{None->ConstantArray[0,nds]};
If[(feynpar=OptionValue[FeynParUF]),
fp=FeynParUF[js[nm,##]&@@ConstantArray[1,nds],NamingFunction->(Array[x,{#}]&)];
xs=Append[Last@fp,x[0]];
fp=Function[t,Append[# D[t,#]&/@Most[xs],t]]/@MonomialList[{x[0],1}.Most@fp,xs];
chzf=Count[#,1]>=MatrixRank[fp/.Thread[Pick[Most@xs,#,0]->0]/.Thread[xs->1]]&;
str="Using Feynman parametrization..."
,
chzf=((dbase={};Solvej[#,dbase,CheckZeroFunction->Factor1,SimplifyFunction->Factor1,SubstituteAlways->False]&/@IBP[nm]@@#;
Collectj[j[nm,##]&@@#//.dbase,Factor1])===0)&;
str="Solving IBPs in the corner points..."
];
nloops=Length@LMs@nm;
sectors=Cases[(IntegerDigits[#1,2,nds]&)/@Range[0,2^nds-1],patt];
nsects=Length@sectors;
LiteRedMonitor[st=(Plus@@#<nloops)&/@sectors;
zsectors=Pick[sectors,st];sectors=Pick[sectors,st,False];
While[sectors=!={},(*While the list has not been depleted*)(*Take the point in the middle of the list*)s1=sectors[[Ceiling[Length@sectors/2]]];
If[(cds=!=(cds*s1))||chzf@s1,(*then move the sector and all its subsectors from sectors to zsectors*)st=jsectge[s1-#]&/@sectors;
zsectors=Join[zsectors,Pick[sectors,st]];
sectors=Pick[sectors,st,False],(*Otherwise,move the sector and all its supersectors from sectors to nzsectors*)st=jsectle[s1-#]&/@sectors;
nzsectors=Join[nzsectors,Pick[sectors,st]];
sectors=Pick[sectors,st,False]]],TableForm[{str,ProgressIndicator[Length@sectors,{nsects,0}]}]];
(*Now form the list of basis sectors*)sectors=Sort[nzsectors,Which[Plus@@#1>Plus@@#2,False,Plus@@#1<Plus@@#2,True,True,OrderedQ[{#1,#2}]]&];
nsects1=Length@sectors;
LiteRedMonitor[While[sectors=!={},s1=First@sectors;
sectors=Rest@sectors;
st=Select[bsectors,jsectge[s1-#]&];
If[st=!={},If[s1=!=BitOr@@st,AppendTo[bsectors,s1]],AppendTo[bsectors,s1];AppendTo[ssectors,s1]]],TableForm[{"Forming SimpleSectors&BasisSectors...",ProgressIndicator[Length@sectors,{nsects1,0}]}]];
zsectors=js[nm,##]&@@@zsectors;
nzsectors=js[nm,##]&@@@nzsectors;
ssectors=js[nm,##]&@@@ssectors;
bsectors=js[nm,##]&@@@bsectors;
ZeroSectors[nm]^=SortBy[zsectors,{Count[#,1],#}&];
NonZeroSectors[nm]^=SortBy[nzsectors,{Count[#,1],#}&];
sectors={};
While[zsectors=!={},(AppendTo[sectors,#];
zsectors=DeleteCases[zsectors,x_/;x<=#])&[Last[zsectors]]];
SimpleSectors[nm]^=SortBy[ssectors,{Count[#,1],#}&];
BasisSectors[nm]^=SortBy[bsectors,{Count[#,1],#}&];
(*17.06.2014*)
CutDs[nm]^=cds;
(*/17.06.2014*)
(*ZerojRule[nm]^=jjj_j\[RuleDelayed]0/;(Or@@(jSector[jjj]\[LessEqual]#&/@#))&[sectors];*)ZerojRule[nm]^=jjj:j[#,__]:>0/;Module[{jjs=Rest[List@@jSector@jjj]},(Or@@(BitOr[jjs,#]===#&/@#2))]&[nm,Rest/@List@@@sectors];
LiteRedPrint["Found "<>#2<>" zero sectors out of "<>#3<>".\n    ZeroSectors["<>#<>"] \[LongDash] zero sectors,\n    NonZeroSectors["<>#<>"] \[LongDash] nonzero sectors,\n    SimpleSectors["<>#<>"] \[LongDash] simple sectors (no nonzero subsectors),\n    BasisSectors["<>#<>"] \[LongDash] basis sectors (at least one immediate subsector is zero),\n    ZerojRule["<>#<>"] \[LongDash] a rule to nullify all zero j["<>#<>"\[Ellipsis]],\n    CutDs["<>#<>"] \[LongDash] a flag list of cut denominatorsj (1=cut)."]&[ToString[nm],ToString@Length@ZeroSectors[nm],ToString@nsects];
If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];]


FindSymmetries::usage="FindSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] finds the symmetries of the sectors of \!\(\*
StyleBox[\"basis\", \"TI\"]\). It generates the following objects:\n\
    UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of unique sectors,\n\
    MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of sectors, equivalent to some unique sectors,\n\
    jRules[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] for each sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of rules mapping integrals to some unique sector,\n\
    jSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"..\", \"TI\"]\)] for each sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of rules mapping unique sector onto itself,\n\
    jSymMatrices[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"..\", \"TI\"]\)] for each sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of matrices mapping unique sector onto itself,\n\
    SR[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns__\", \"TI\"]\)] for any integral j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in one of the UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of symmetry relations for the specific integral.\n\
Each j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in one of the  MappedSectors[basis] can be mapped onto one of the UniqueSectors[basis] (and subsectors) using j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)]/.(jRules@@jSector[j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)]]).\n\
\n\
Note that FindSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] requires running AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] beforehand and considers only sectors in NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)], generated by AnalyzeSectors.";
UniqueSectors::usage="UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of unique sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\), i.e.,\
 those sectors in NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] onto which all other sectors NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] can be mapped (those are gathered in MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]).";
MappedSectors::usage="MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) which can be mapped onto the UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";
jRules::usage="jRules[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the reduction rule(s) for a given sector.";
jSymmetries::usage="jSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the list of rules mapping unique sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] onto itself.";
jSymMatrices::usage="jSymMatrices[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the list of (N+1)\[Times](N+1) matrices, which map unique sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] onto itself.";
SR::usage="SR[\!\(\*
StyleBox[\"basis\", \"TI\"]\)][\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)] gives the list of symmetry relations for the integral j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)].";
jsOrderingFunction::usage="jsOrderingFunction is an option of FindSymmetries to define which sectors with a given \
number of denominators are simpler. By default it is set to Identity.";


Options[FindSymmetries]={NamingFunction->Automatic,
EMs->False,jsOrderingFunction->Identity,jSymMatrices->False,ExtUniqueSectors->True};


FindSymmetries::noss="No sectors found. Forgot to analyze sectors with AnalyzeSectors[`1`]?";
FindSymmetries::noshift="Warning: FP-equivalent sectors `1` are not shift-equivalent. Some symmetries are lost.";
FindSymmetries::opt="Something wrong in option `1`. Ignoring it.";


FindSymmetries[nm_,OptionsPattern[]]:=Module[
{ss,nzs,nzs0,so,euso,
x,y,fp,inds,cds=Append[CutDs@nm,0],
NDs=Length@Ds@nm,lms=LMs@nm,ems=EMs@nm,
m,gle,rule,egle,erule,emsn,oems,
dd,params,dmatr,matr,xeqs={},m2rule,
us,ujs,es,jsec,s,subs,t,l,sol,i,jsyms},
If[!ValueQ[Ds@nm]||!ValueQ[LMs@nm],Message[NewBasis::notb];Return[$Failed]];
If[!ValueQ[SimpleSectors@nm],Message[FindSymmetries::noss,nm];Return[$Failed]];
If[!ValueQ[NonZeroSectors@nm],Message[FindSymmetries::noss,nm];Return[$Failed]];
so=OptionValue@jsOrderingFunction;
euso=OptionValue[ExtUniqueSectors];
jsyms=OptionValue@jSymMatrices;
If[euso&&ValueQ[ExtUniqueSectors[nm]],
nzs0=nzs=SortBy[ExtUniqueSectors@nm,{Count[#,1],so@#}&[Rest[List@@#]]&],
nzs0=nzs=SortBy[NonZeroSectors@nm,{Count[#,1],so@#}&[Rest[List@@#]]&]
];
(*\:0412 \:043f\:0440\:0438\:043d\:0446\:0438\:043f\:0435, \:043d\:0435 \:043e\:0431\:044f\:0437\:0430\:0442\:0435\:043b\:044c\:043d\:043e \:0438\:0441\:043a\:0430\:0442\:044c \:043a\:0430\:043d\:043e\:043d\:0438\:0447\:0435\:0441\:043a\:0438\:0439 \:0432\:0438\:0434 \:0432 \:043a\:0430\:0436\:0434\:043e\:043c \:0441\:0435\:043a\:0442\:043e\:0440\:0435, \:043d\:043e \:0437\:0430\:0442\:043e \:043f\:0440\:043e\:0441\:0442\:043e!*)
LiteRedPrintTemporary["Constructing Feynman parametrization..."];
fp=Plus@@Most@FeynParUF[js[nm,##]&@@ConstantArray[1,NDs],NamingFunction->(Array[x,{#}]&)];
LiteRedPrintTemporary["Using Feynman parametrization to determine equivalent simple sectors..."];
ss=SortBy[SimpleSectors@nm,{Count[#,1],so@#}&[Rest[List@@#]]&];t=Length@ss;
LiteRedMonitor[i=0;
ss=Append[polyNF[fp/.Thread[x@@@Position[Rest@#,0,1]->0],x@@@Position[Rest@#,1,1]]/.x->(#&),i++;#]&/@ss,(*********15.10.2013*************************)
ProgressIndicator[i,{0,t}]
];
ss=SortBy[#,Last]&/@Map[Rest,GatherBy[ss,First],{2}];
(*********15.10.2013*************************)
(*********16.10.2013*************************)
(*\:0420\:0435\:0448\:0435\:043d\:0438\:0435 \:0442\:0430\:043a\:043e\:0435: \:0441\:0434\:0435\:043b\:0430\:0442\:044c \:0438\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:043d\:0438\:0435 \:043e\:043f\:0446\:0438\:0438 EMs\[Rule]True \:043d\:0435\:0436\:0435\:043b\:0430\:0442\:0435\:043b\:044c\:043d\:044b\:043c (\:0442.\:043a. \:0435\:0441\:0442\:044c \:043f\:0440\:0438\:043c\:0435\:0440\:044b, \:043a\:043e\:0433\:0434\:0430 \:0430\:0432\:0442\:043e\:043c\:0430\:0442\:0438\:0447\:0435\:0441\:043a\:043e\:0435 \:043e\:043f\:0440\:0435\:0434\:0435\:043b\:0435\:043d\:0438\:0435 \:0432\:043e\:0437\:043c\:043e\:0436\:043d\:044b\:0445 \:0437\:0430\:043c\:0435\:043d \:043e\:0441\:0442\:0430\:0432\:043b\:044f\:0435\:0442 \:0441\:0432\:043e\:0431\:043e\:0434\:043d\:044b\:0446\:0435 \:043f\:0430\:0440\:0430\:043c\:0435\:0442\:0440\:044b)
\:0412\:043c\:0435\:0441\:0442\:043e \:044d\:0442\:043e\:0433\:043e \:0434\:043e\:043b\:0436\:043d\:043e \:0431\:044b\:0442\:044c \:0432\:043e\:0437\:043c\:043e\:0436\:043d\:044b\:043c \:0443\:043a\:0430\:0437\:0430\:043d\:0438\:0435 \:0441\:043f\:0438\:0441\:043a\:0430 \:0437\:0430\:043c\:0435\:043d \:0432\:043d\:0435\:0448\:043d\:0438\:0445 \:0438\:043c\:043f\:0443\:043b\:044c\:0441\:043e\:0432.*)
gle=Array[m,{Length@lms,Length@lms+Length@ems}];
rule=Thread[lms->gle.Join[lms,ems]];
Declare[Evaluate@(gle=Flatten@gle),Number];
oems=Replace[OptionValue[EMs],{
False->{{}},
True:>(egle=Array[m,{Length@ems,Length@ems},Length@lms+1];
erule=Thread[ems->egle.ems];t=ems/.erule;
Declare[Evaluate@(egle=Flatten@egle),Number];gle=Join[gle,egle];
xeqs=DeleteCases[sp@@@Subsets[ems,2]-LFDistribute[sp@@@Subsets[t,2]],0];(*this string uses that sp[a]\[Rule]sp[a,a]*)
If[xeqs=!={},xeqs=GroebnerBasis[Reap[Collect[xeqs,Select[Variables[{MetricTensor[],sp@@@Subsets[ems,{2}],LFDistribute@Ds@nm}],FreeQ[#,Alternatives@@lms]&],Sow]][[-1,-1]],egle]];
(*\:0412\:043e\:0437\:0432\:0440\:0430\:0449\:0430\:0435\:043c \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0434\:043b\:044f \:0432\:043d\:0435\:0448\:043d\:0438\:0445 \:0438\:043c\:043f\:0443\:043b\:044c\:0441\:043e\:0432*){erule}),
t:{__List}:>(
(*\:0417\:0434\:0435\:0441\:044c \:0434\:0435\:043b\:0430\:0435\:043c \:043f\:0440\:043e\:0432\:0435\:0440\:043a\:0443*)
If[Complement[Join@@t[[All,All,1]],ems]=!={}||!FreeQ[t,Alternatives@@LMs@nm]||DeleteDuplicates@Flatten[Factor[LFDistribute[sp@@@Subsets[ems,2]-sp@@@Subsets[ems/.#,2]]&/@t]]=!={0},
Message[FindSymmetries::opt,EMs->t];{{}},
t]),
__:>(Message[FindExtSymmetries::opt,EMs->t];{{}})
}];
dmatr=Append[Outer[Coefficient,Toj[nm,Ds@nm/.rule/.#],Toj[nm,Append[Ds@nm,1]]],PadLeft[{1},NDs+1]]&/@oems;(*\:0442\:0435\:043f\:0435\:0440\:044c \:044d\:0442\:043e \:0441\:043f\:0438\:0441\:043e\:043a \:043c\:0430\:0442\:0440\:0438\:0446, \:043a\:0430\:0436\:0434\:044b\:0439 \:044d\:043b\:0435\:043c\:0435\:043d\:0442 \:0441\:043e\:043e\:0442\:0432\:0435\:0442\:0441\:0442\:0432\:0443\:0435\:0442 \:0432\:043d\:0435\:0448\:043d\:0435\:0439 \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438*)
LiteRedPrintTemporary["Constructing shifts for simple sectors..."];
(*\:041b\:044e\:0431\:043e\:0439 \:043d\:0435\:043d\:0443\:043b\:0435\:0432\:043e\:0439 \:0441\:0435\:043a\:0442\:043e\:0440 \:043d\:0430 \:044d\:0442\:043e\:043c \:044d\:0442\:0430\:043f\:0435 \:0434\:043e\:043b\:0436\:0435\:043d \:0441\:043e\:0434\:0435\:0440\:0436\:0430\:0442\:044c \:0432\:0441\:0435 \:0440\:0430\:0437\:0440\:0435\:0437\:0430\:043d\:043d\:044b\:0435. \:041f\:043e\:044d\:0442\:043e\:043c\:0443 \:0434\:043e\:0441\:0442\:0430\:0442\:043e\:0447\:043d\:043e \:043f\:0440\:043e\:0441\:043b\:0435\:0434\:0438\:0442\:044c \:0447\:0442\:043e\:0431\:044b SimpleSectors
\:043e\:0442\:043e\:0431\:0440\:0430\:0436\:0430\:043b\:0438\:0441\:044c \:043f\:0440\:0430\:0432\:0438\:043b\:044c\:043d\:043e (\:0442.\:0435., \:0440\:0430\:0437\:0440\:0435\:0437\:0430\:043d\:043d\:044b\:0435 \:0432 \:0440\:0430\:0437\:0440\:0435\:0437\:0430\:043d\:043d\:044b\:0435)*)
LiteRedMonitor[i=0;ss=SortBy[Flatten[(s={};
Function[{top,ujs},i++;jsec=ujs;
Catch[Do[
Outer[(sol=Solve[0==GroebnerBasis[Flatten@{#1[[#2]]-s[[k,1]],xeqs},gle],gle];
(*If[{}=!=sol,s\[LeftDoubleBracket]k,2\[RightDoubleBracket]=Append[s\[LeftDoubleBracket]k,2\[RightDoubleBracket],ujs];s\[LeftDoubleBracket]k,4\[RightDoubleBracket]=Append[s\[LeftDoubleBracket]k,4\[RightDoubleBracket],#/.First@sol];Throw[Null]]*)
Function[sr(*solution rules*),matr=#1/.sr;
If[Factor[cds*matr.cds]===cds,s[[k,2]]=Append[s[[k,2]],ujs];s[[k,4]]=Append[s[[k,4]],matr];Throw[Null]]]/@sol)&,dmatr,top,1],
{k,Length@s}];(*********15.10.2013*************************)
(*No mapping onto so far unique*)
t=RotateRight[PadLeft[{1},NDs+1],#]&/@First@top;
AppendTo[s,{t,{ujs},DeleteDuplicates[Flatten[Outer[Function[{m,tp},
Select[m/.#&/@Solve[0==GroebnerBasis[Flatten@{m[[tp]]-t,xeqs},gle],gle],Factor[cds*#.cds]===cds&]],dmatr,top,1],2]](*self shifts*),
{(*a place for shift from other topologies*)}}]
]
(*Catch[Do[
Scan[(sol=Solve[0==GroebnerBasis[Flatten@{#[[First@top]]-s[[k,1]],xeqs},gle],gle];
If[{}=!=sol,s[[k,2]]=Append[s[[k,2]],ujs];s[[k,4]]=Append[s[[k,4]],#/.First@sol];Throw[Null]])&,dmatr],
{k,Length@s}];(*********15.10.2013*************************)
(*No mapping onto so far unique*)
t=RotateRight[PadLeft[{1},NDs+1],#]&/@First@top;
AppendTo[s,{t,{ujs},DeleteDuplicates[Flatten[Outer[Function[{m,tp},m/.#&/@Solve[0==GroebnerBasis[Flatten@{m[[tp]]-t,xeqs},gle],gle]],dmatr,top,1],2]](*self shifts*),
{(*a place for shift from other topologies*)}}
]
]*)]@@@#;(******************************************)
(*issue a warning if FP equivalent sectors are not shift equivalent*)
 (*If[Length@s>1,Message[FindSymmetries::noshift,s\[LeftDoubleBracket]All,2,1\[RightDoubleBracket]]];*)
 Rest/@s
)&/@ss,1],(-Count[First@First@#,1])&],
TableForm[{{ProgressIndicator[i,{0,#}]},{jsec}}]
]&[Plus@@Length/@ss];
LiteRedPrintTemporary["    Found "<>ToString[Length@ss]<>" unique simple sectors with degeneracies "<>ToString[StringTake[ToString@(Length/@First/@ss),{2,-2}]]<>" respectively."];
(*At this point the only result is ss, which has the form {{{js[\[Ellipsis]],\[Ellipsis]},{ss1,\[Ellipsis]},{s1,\[Ellipsis]}},\[Ellipsis]} number of denominators is decreasing*)
LiteRedPrintTemporary["Constructing shifts for all nonzero sectors..."];
LiteRedMonitor[
While[nzs=!={},
ujs=First@nzs;
{i} = Position[First /@ ss, x_?(#<=ujs &), {2}, 1];
(*\:041e\:0431\:044f\:0437\:0430\:043d\:0430 \:0431\:044b\:0442\:044c \:0445\:043e\:0442\:044f \:0431\:044b \:043e\:0434\:043d\:0430 \:043f\:043e\:0434\:0442\:043e\:043f\:043e\:043b\:043e\:0433\:0438\:044f*)
{subs,us,es}=ss[[First@i]];
t=Last@i;If[t>1,us=es[[t-1]].#&/@us];
s=Factor@Join[us,Flatten[Outer[Dot,us,Inverse/@es,1],1]];(*\:0421\:043f\:0438\:0441\:043e\:043a \:0432\:0441\:0435\:0445 \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0439 \:043f\:043e\:0434\:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
us={};es={};
s=DeleteDuplicates@s;
Scan[(t=Pick[Most@#,List@@Rest@ujs,1];
If[MatchQ[t,{{0...,1,0...}..}],
(*\:0421\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:044f \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
t=Most[Plus@@t];
If[t===List@@Rest@ujs,
AppendTo[us,#](*\:0441\:043e\:0431\:0441\:0442\:0432\:0435\:043d\:043d\:0430\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:044f \:0441\:0435\:043a\:0442\:043e\:0440\:0430*),
AppendTo[es,{js[nm,##]&@@t,#}](*\:043d\:0435\:0441\:043e\:0431\:0441\:0442\:0432\:0435\:043d\:043d\:0430\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:044f \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
]
])&,s];
es=SortBy[es,-Count[Last@#,{0...,1,0...}]&];
(*\:0422\:0435\:043f\:0435\:0440\:044c \:0443\:0434\:0430\:043b\:044f\:0435\:043c \:0438\:0437 es \:043b\:0438\:0448\:043d\:0438\:0435 \:0441\:0434\:0432\:0438\:0433\:0438, \:043e\:0434\:043d\:043e\:0432\:0440\:0435\:043c\:0435\:043d\:043d\:043e \:0444\:043e\:0440\:043c\:0438\:0440\:0443\:044f \:0441\:0435\:043a\:0442\:043e\:0440\:0430 \:0433\:0440\:0443\:043f\:043f\:044b*)
s={ujs};
es=DeleteCases[(
If[MemberQ[nzs,#1]&&!MemberQ[s,#1],
(*\:0442\:0430\:043a\:043e\:0433\:043e \:0441\:0435\:043a\:0442\:043e\:0440\:0430 \:0435\:0449\:0435 \:043d\:0435\:0442 \:0432 \:0433\:0440\:0443\:043f\:043f\:0435*)
AppendTo[s,#1];Inverse@#2
,
Null
]
)&@@@es,Null];
nzs=DeleteCases[nzs,Alternatives@@s];
If[MemberQ[subs,ujs],
ss[[First@i]]={s,us,es},
PrependTo[ss,{s,us,es}]
]
],
TableForm[{{ProgressIndicator[#-Length@nzs,{0,#}]},{ujs}}]
]&[Length@nzs];
LiteRedPrintTemporary["    Found "<>ToString[Length@ss]<>" unique sectors with degeneracies "<>ToString[StringTake[ToString@(Length/@First/@ss),{2,-2}]]<>" respectively."];
LiteRedPrintTemporary["Forming rules..."];
inds=Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][NDs];
(********************************************************************************)
m2rule=Function[{ujs,m},(j[nm,##]&@@(If[#1==1,"pt"["p"[#2,Blank[]],Positive],"pt"["p"[#2,Blank[]],NonPositive]]&@@@Transpose[{List@@Rest@ujs,inds}])/.{"pt"->PatternTest,"p"->Pattern})/;True:>Expand[#]&[Times@@(Toj[nm,Most[m].Append[Ds@nm,(*\:0415\:0434\:0438\:043d\:0438\:0446\:0430*)j[nm,Sequence@@ConstantArray[0,NDs]]]]^-inds)]
];
LiteRedMonitor[
i=0;Scan[
(i++;jsec=ujs=#[[1,1]];(*\:0443\:043d\:0438\:043a\:0430\:043b\:044c\:043d\:044b\:0439 \:0441\:0435\:043a\:0442\:043e\:0440*)
If[MemberQ[nzs0,ujs],
us=#[[2]];(*\:0441\:043e\:0431\:0441\:0442\:0432\:0435\:043d\:043d\:044b\:0435 \:0441\:0434\:0432\:0438\:0433\:0438*)
(*\:0424\:043e\:0440\:043c\:0438\:0440\:0443\:0435\:043c \:0441\:043e\:0431\:0441\:0442\:0432\:0435\:043d\:043d\:044b\:0435 \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438*)
 If[jsyms,nm/:jSymMatrices[Sequence@@ujs]=us];
nm/:jSymmetries[Sequence@@ujs]=({m2rule[ujs,#]}&/@us)
];
(*\:0424\:043e\:0440\:043c\:0438\:0440\:0443\:0435\:043c \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438 \:0434\:043b\:044f \:044d\:043a\:0432\:0438\:0432\:0430\:043b\:0435\:043d\:0442\:043d\:044b\:0445 \:0441\:0435\:043a\:0442\:043e\:0440\:043e\:0432*)
(jsec=ujs\[LeftArrow]#1;nm/:jRules[Sequence@@#1]={m2rule[##]})&@@@Cases[(*added 14.10.2013*)Transpose[{Rest@First@#,Last@#}],{_?(MemberQ[nzs0,#]&),_}];
)&,
ss]
,
TableForm[{{ProgressIndicator[i,{0,#}]},{jsec}}]
]&[Plus@@Length/@ss];
UniqueSectors[nm]^=SortBy[Intersection[ss[[All,1,1]],nzs0],{Count[#,1],#}&];
MappedSectors[nm]^=SortBy[Intersection[Join@@Rest/@ss[[All,1]],nzs0],{Count[#,1],#}&];
SR[nm]^=Function[Module[{jsc=jSector@j[nm,##]},
If[MemberQ[UniqueSectors@nm,jsc],
DeleteCases[DeleteDuplicates[Collectj[j[nm,##]-(j[nm,##]/.jSymmetries@@jsc)]],0],
{}
]
]];
LiteRedPrint["Found "<>ToString[Length@MappedSectors@nm]<>" mapped sectors and "<>ToString[Length@UniqueSectors@nm]<>" unique sectors.\n\    UniqueSectors["<>ToString[nm]<>"] \[LongDash] unique sectors.\n\    MappedSectors["<>ToString[nm]<>"] \[LongDash] mapped sectors.\n\    SR["<>ToString[nm]<>"][\[Ellipsis]] \[LongDash] symmetry relations for j["<>ToString[nm]<>",\[Ellipsis]] from UniqueSectors["<>ToString[nm]<>"].\n\    jSymmetries["<>ToString[nm]<>",\[Ellipsis]] \[LongDash] symmetry rules for the sector js["<>ToString[nm]<>",\[Ellipsis]] in UniqueSectors["<>ToString[nm]<>"].\n\    jRules["<>ToString[nm]<>",\[Ellipsis]] \[LongDash] reduction rules for j["<>ToString[nm]<>",\[Ellipsis]] from MappedSectors["<>ToString[nm]<>"]."];
If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];
]


Options[IdentifyMIs]={IBPReduce->True,Save->False};
IdentifyMIs::usage="IdentifyMIs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] uses Feynman parametrization approach to find possible mapings between masters.\nOptions:\n    IBPReduce\[Rule]True|False:True determines whether to perform ibp reduction after mapping (since the result of the mapping is not necessarily a master)\n    Save\[Rule]True|False:False determines whether to exclude mapped master integrals from MIs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] and to append found rules to jRules of the corresponding sector (which means they will be used in IBPReduce).";
IdentifyMIs::norules="Somehow, no rules found for the sector `1`. Skipping it.";


IdentifyMIs[nm_,OptionsPattern[]]:=Module[{jr,ibp,g,x,t,t1,p,ps,xs,mis,a,nds=Length@Ds@nm,inds,res,jsec},
{jr,ibp}={TrueQ@OptionValue@Save,TrueQ@OptionValue@IBPReduce};
{g,t,xs}=FeynParUF[nm,NamingFunction->(Array[x,{#}]&)];g=g+t/.(#->a # &/@Pick[xs,CutDs[nm],1]);
If[!ValueQ[MIs[nm]],(*message*)Return[$Failed]];
mis=Select[GatherBy[{polyNF[g/.Thread[Pick[xs,Rest[List@@#[[1,1]]],0]->0],Pick[xs,Rest[List@@#[[1,1]]],1]]/.x->(#&),Last/@#}&/@GatherBy[SortBy[{jSector@#,#}&/@MIs[nm],First],First],#[[1,1]]&],Length@#>1&];
If[mis=={},Return[{}]];
mis=MapAt[#[[-1,1]]&,mis,{All,All,1}];
res=Flatten[Function[list,p=list[[1,1]];inds=Table[Unique["n"],{Length@p}];
(**)
t=ConstantArray[0,nds];t[[p]]=inds;
(t1=ConstantArray[0,nds];t1[[#[[1]]]]=Pattern[#,Blank[]]&/@inds;Thread[#[[2]]->(FromDShifts/@(ToDShifts/@#[[2]]/.(j[nm,##]&@@t1:>j[nm,##]&@@t)))]
)&/@Rest[list]
 ]/@mis,1];
(*additional processing*)
If[ibp,
res[[All,All,2]]=IBPReduce[res[[All,All,2]]]];
If[jr,
(*Add appropriate rules, try to follow standards*)
(jsec=jSector[#[[1,1]]];t=jRules@@jsec;
If[Head[t]===List&&t=!={},
t1=t[[1,1,1]];
t=Join[t,((t1/;#)&[And@@Thread[Rest[List@@t1][[All,1,1]]==Rest[List@@#1]]]:>#2)&@@@#];
t1=Select[UpValues[nm],Function[sec,(#[[1]]===HoldPattern[sec]&)][jsec]/.js->jRules,1][[1]];
If[t1[[2,0]]===Get,
Put[t,t1[[2,1]]];
,
(#1/:jRules[##]=t)&@@jsec
];
Print["Appended "<>ToString[Length@#]<>" rules to "<>StringReplace[ToString[jsec],"js"->"jRules"]<>"."],
Message[IdentifyMIs::norules,jsec]
];
)&/@res;
t=Flatten[res[[All,All,1]]];
MIs[nm]^=jVars[Complement[MIs[nm],t]];
Print["Removed "<>ToString[t]<>" from MIs["<>ToString[nm]<>"]."]
];
Flatten@res
]


FindExtSymmetries::usage="FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\)] finds the mappings of the sectors of \!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\) to unique sectors of \!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\). It generates the following objects:\n\
    ExtUniqueSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] \[LongDash] the list of sectors which can not be mapped,\n\
    ExtMappedSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] \[LongDash] the list of sectors, equivalent to some unique sectors of \!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\),\n\
    jExtRules[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] for each sector js[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in ExtMappedSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] \[LongDash] the list of rules mapping integrals to some unique sector of \!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\).\n\
Note that FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\)] requires running AnalyzeSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] and FindSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\)] beforehand. If afterwards FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(3\)]\)] is called, it tries to map only those sectors which are in ExtUniqueSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] and modifies correspondingly the lists ExtUniqueSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] and  ExtMappedSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)].\n\
FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(k\)]\)] is a shortcut for FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(k\)]\)];FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(k - 1\)]\)];FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\)] \[LongDash] mind the order.";
ExtUniqueSectors::usage="ExtUniqueSectors[basis] is the list of unique sectors of the basis, i.e., those sectors in NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] which can not be mapped onto other bases.";
ExtMappedSectors::usage="ExtMappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) which can be mapped onto sectors of some other bases.";
jExtRules::usage="jExtRules[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the reduction rule(s) for a given sector, which map it onto the sector of another basis.";


Options[FindExtSymmetries]={NamingFunction->Automatic,EMs->False};
FindExtSymmetries::basisorder="The bases names are not properly ordered.";
FindExtSymmetries::nosectors="Run `2`[`1`] first. Aborting...";
FindExtSymmetries::opt="Something wrong in option `1`. Ignoring it.";
FindExtSymmetries[b1_Symbol,b2_Symbol,bs__Symbol,opts:OptionsPattern[]]:=FindExtSymmetries[b1,#1,opts]&/@Reverse[{b2,bs}];
(*FindExtSymmetries[bs:(_,_,__),opts:OptionsPattern[]]:=FindExtSymmetries[#1,#2,opts]&@@@Reverse[Subsets[{bs},{2}]];*)
FindExtSymmetries[b1_Symbol,b2_Symbol,OptionsPattern[]]:=Module[
{nzs1,us2,l,i,k,pt,
xs,x,fp,pnf,t,jsm,
dmatr,matr,cs,
lms1=LMs[b1],
lms2=LMs[b2],
ems1=EMs[b1],
ems2=EMs[b2],
ds1=Ds[b1],
ds2=Ds[b2],
cds1=CutDs[b1],
cds2=Append[CutDs[b2],0],
sol,m2rule,
inds,ems,empd={}
},
If[OrderedQ[{b1,b2}],Message[FindExtSymmetries::basisorder]];
pt=LiteRedPrintTemporary["Forming signatures for unique sectors..."];
xs=Array[x,{Length@Ds[b2]}];
fp=Plus@@Most@FeynParUF[b2,NamingFunction->(xs&)];
us2=UniqueSectors[b2];l=Length@us2;
Assert[Head[us2]===List];
If[Head[us2]===UniqueSectors,Message[FindExtSymmetries::nosectors,"FindSymmetries",b2];Abort[]];
NotebookDelete[pt];
i=0;LiteRedMonitor[
us2=Function[js2,i++;jsm=js2;{js2,#1,#2[[1,All,1]]}&@@polyNF[fp/.Thread[Pick[xs,List@@Rest@js2,0]->0],Pick[xs,List@@Rest@js2,1]]]/@us2,
TableForm[{"Forming signatures for unique sectors",ProgressIndicator[i,{0,l}],jsm
}]];
(* sgn2 \[LongDash] \:0441\:043f\:0438\:0441\:043e\:043a \:0441 \:044d\:043b\:0435\:043c\:0435\:043d\:0442\:0430\:043c\:0438 {js[\[Ellipsis]],signature_List,inds_List} *)
(*\:0414\:043b\:044f \:043a\:0430\:0436\:0434\:043e\:0433\:043e \:043d\:0435\:043d\:0443\:043b\:0435\:0432\:043e\:0433\:043e \:0441\:0435\:043a\:0442\:043e\:0440\:0430 \:043f\:0435\:0440\:0432\:043e\:0433\:043e \:0431\:0430\:0437\:0438\:0441\:0430 \:0438\:0449\:0435\:043c \:043f\:043e\:0434\:0445\:043e\:0434\:044f\:0449\:0438\:0439 \:0441\:0435\:043a\:0442\:043e\:0440 \:0432\:0442\:043e\:0440\:043e\:0433\:043e, \:0438 \:0435\:0441\:043b\:0438 \:043e\:043d \:043d\:0430\:0439\:0434\:0435\:043d, \:0438\:0449\:0435\:043c \:043c\:044d\:043f\:043f\:0438\:043d\:0433*)
pt=LiteRedPrintTemporary["Searching for mappings..."];
fp=Plus@@Most@FeynParUF[b1,NamingFunction->(xs&)];
If[!ValueQ[ExtUniqueSectors[b1]],ExtUniqueSectors[b1]^=NonZeroSectors[b1]];
nzs1=ExtUniqueSectors[b1];l=Length@nzs1;
If[Head[nzs1]===NonZeroSectors,Message[FindExtSymmetries::nosectors,"FindSymmetries",b1];Abort[]];
(*\:043a\:043e\:043d\:0441\:0442\:0440\:0443\:0438\:0440\:0443\:0435\:043c \:043c\:0430\:0442\:0440\:0438\:0446\:0443 \:0437\:0430\:043c\:0435\:043d\:044b \:0437\:043d\:0430\:043c\:0435\:043d\:0430\:0442\:0435\:043b\:0435\:0439*)
(*\:041f\:0440\:0435\:0434\:043f\:043e\:043b\:0430\:0433\:0430\:0435\:043c, \:0447\:0442\:043e \:0447\:0438\:0441\:043b\:043e \:043f\:0435\:0442\:043b\:0435\:0432\:044b\:0445 \:0438\:043c\:043f\:0443\:043b\:044c\:0441\:043e\:0432 \:0441\:043e\:0432\:043f\:0430\:0434\:0430\:0435\:0442 \:0438 \:0447\:0442\:043e \:0441\:043e\:0432\:043f\:0430\:0434\:0430\:044e\:0442 \:0432\:0441\:0435 \:0432\:043d\:0435\:0448\:043d\:0438\:0435 \:0438\:043c\:043f\:0443\:043b\:044c\:0441\:044b*)
(**)
ems=Replace[OptionValue[EMs],{
False:>{{}},
t:{__List}:>((*\:0417\:0434\:0435\:0441\:044c \:0434\:0435\:043b\:0430\:0435\:043c \:043f\:0440\:043e\:0432\:0435\:0440\:043a\:0443*)
If[Complement[Join@@t[[All,All,1]],ems1]=!={}||!FreeQ[t,Alternatives@@Union[lms1,lms2]]||DeleteDuplicates@Flatten[Factor[LFDistribute[sp@@@Subsets[ems1,2]-sp@@@Subsets[ems1/.#,2]]&/@t]]=!={0},
Message[FindExtSymmetries::opt,EMs->t];{{}},t]),
t_:>(Message[FindExtSymmetries::opt,EMs->t];{{}})
}];
(**)
cs=Array[Unique["c"],{Length@lms2,Length@lms2+Length@ems2}];Declare[Evaluate@Flatten@cs,Number];(*(*\:0422\:0430\:043a \:0431\:044b\:043b\:043e \:0431\:0435\:0437 ems*)dmatr=Outer[Coefficient,Toj[b2,ds1/.Thread[lms1\[Rule](cs.Join[lms2,ems2])]],Toj[b2,Append[ds2,1]]];*)
dmatr=Outer[Coefficient,Toj[b2,ds1/.Thread[lms1->(cs.Join[lms2,ems2])]/.#],Toj[b2,Append[ds2,1]]]&/@ems;
(*ds1\[Rule]dmatr.Append[ds2,1]*)
(*/*)
NotebookDelete[pt];
i=0;LiteRedMonitor[
Function[sec,
i++;jsm=sec;
(**)
pnf={#1,#2[[1,All,1]]}&@@polyNF[fp/.Thread[Pick[xs,List@@Rest@sec,0]->0],Pick[xs,List@@Rest@sec,1]];
(*(*before 17.06.2014*)
t=Cases[us2,{_,First@pnf,_},1,1];
If[t=!={},
t=First@t;jsm=sec\[Rule]First@t;
(*\:043d\:0443\:0436\:043d\:043e \:043d\:0430\:0439\:0442\:0438 \:043c\:044d\:043f\:043f\:0438\:043d\:0433*)
(*\:043d\:043e\:043c\:0435\:0440\:0430 \:0437\:043d\:0430\:043c\:0435\:043d\:0430\:0442\:0435\:043b\:0435\:0439  Last@pnf \:043f\:0435\:0440\:0432\:043e\:0433\:043e \:0431\:0430\:0437\:0438\:0441\:0430 \:043f\:0435\:0440\:0435\:0445\:043e\:0434\:044f\:0442 \:0432 \:043d\:043e\:043c\:0435\:0440\:0430 Last@t \:0432\:0442\:043e\:0440\:043e\:0433\:043e \:0431\:0430\:0437\:0438\:0441\:0430*)
Do[
sol=Solve[0==GroebnerBasis[dmatr\[LeftDoubleBracket]k,Last@pnf\[RightDoubleBracket]-(PadRight[PadLeft[{1},#],Length@ds2+1]&/@Last@t),Flatten[cs]]];
If[{}=!=sol,
(*rule found*)
inds=Replace[OptionValue[NamingFunction],Automatic\[RuleDelayed]$NamingFunction][Length@ds1];
b1/:jExtRules[Sequence@@sec]=(j[b1,##]&@@(If[#1\[Equal]1,"pt"["p"[#2,Blank[]],Positive],"pt"["p"[#2,Blank[]],NonPositive]]&@@@Transpose[{List@@Rest@sec,inds}])/.{"pt"\[Rule]PatternTest,"p"\[Rule]Pattern})(*/lhs*)\[RuleDelayed]Expand[#]&[Times@@(Toj[b2,(dmatr\[LeftDoubleBracket]k\[RightDoubleBracket]/.First@sol).Append[Ds@b2,(*\:0415\:0434\:0438\:043d\:0438\:0446\:0430*)j[b2,Sequence@@ConstantArray[0,Length@ds1]]]]^-inds)];
AppendTo[empd,sec];
Break[]
]
,{k,Length@dmatr}];
]*)
(*after 17.06.2014*)
Catch[
(jsm=sec->First@#;
Do[
sol=Solve[0==GroebnerBasis[dmatr[[k,Last@pnf]]-(PadRight[PadLeft[{1},#],Length@ds2+1]&/@Last@#),Flatten[cs]]];
Function[sr,
inds=Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][Length@ds1];
matr=dmatr[[k]]/.sr;
If[(****)Factor[cds1*(matr.cds2)]===cds1,
b1/:jExtRules[Sequence@@sec]=(j[b1,##]&@@(If[#1==1,"pt"["p"[#2,Blank[]],Positive],"pt"["p"[#2,Blank[]],NonPositive]]&@@@Transpose[{List@@Rest@sec,inds}])/.{"pt"->PatternTest,"p"->Pattern})(*/lhs*):>Expand[#]&[Times@@(Toj[b2,matr.Append[Ds@b2,(*\:0415\:0434\:0438\:043d\:0438\:0446\:0430*)j[b2,Sequence@@ConstantArray[0,Length@ds1]]]]^-inds)];
AppendTo[empd,sec];
Throw[Null]]]/@sol
,{k,Length@dmatr}])&/@Cases[us2,{_,First@pnf,_},1]
](*/after 17.06.2014*)
]/@nzs1,
TableForm[{"Searching for mappings",
ProgressIndicator[i,{0,l}],
jsm}]
];
If[ValueQ[ExtMappedSectors[b1]],ExtMappedSectors[b1]^=SortBy[Join[ExtMappedSectors[b1],empd],{Count[#,1],#}&],ExtMappedSectors[b1]^=empd];
ExtUniqueSectors[b1]^=SortBy[Complement[ExtUniqueSectors[b1],empd],{Count[#,1],#}&];
LiteRedPrint["Found "<>ToString[Length@empd]<>" mapped sectors.\n    ExtUniqueSectors["<>ToString[b1]<>"] \[LongDash] new sectors of the basis.\n\    ExtMappedSectors["<>ToString[b1]<>"] \[LongDash] a list of mapped sectors,\n    jExtRules["<>ToString[b1]<>",\[Ellipsis]] \[LongDash] reduction rules for j["<>ToString[b1]<>",\[Ellipsis]] from ExtMappedSectors["<>ToString[b1]<>"]."];
]


IBPReduce::usage="IBPReduce[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] performs the reduction of the \!\(\*
StyleBox[\"expr\", \"TI\"]\) applying rules found by FindSymmetries and SolvejSector";
(*DWeight::usage="DWeight\[Rule]n  is an option for IBPReduce which determines the extra priority points for each denominator.";*)


Options[IBPReduce]={jExtRules->True};


IBPReduce[expr_,OptionsPattern[]]:=Module[
{er,
dir,i=0,res,
jplist,jplist1,jlist,jsd,nd,nd1,
jlist1,lock,
rs0,rs,nrs,f,jc,jsector=Replace[js@@#,{_?Positive->1,_?NonPositive->0},{1}]&,
jsec,lsecs,hjsec,hjsecn,
t1,t2,jrules,jrules1,jrules2,rc,
pos,mis={},
nr=0,nr1=0,level,
lvl,
status},
Block[{jRules},
jRules[__]={};
er=OptionValue[jExtRules];While[DirectoryQ[dir="IBPReduction"<>ToString[++i]],Continue[]];CreateDirectory[dir];
(*\:0441\:043e\:0431\:0438\:0440\:0430\:0435\:043c \:0432\:0441\:0435 j, \:043e\:043f\:0440\:0435\:0434\:0435\:043b\:044f\:0435\:043c \:0441\:043b\:043e\:0436\:043d\:0435\:0439\:0448\:0438\:0439 \:0441\:0435\:043a\:0442\:043e\:0440*)
CheckAbort[
jplist={#,jsector@#}&/@DeleteDuplicates@Cases[{expr},_j,\[Infinity]];
If[jplist==={},Return[expr]];
jsd={"res"->((*{#1,FromDigits[{##2},2]}&@@@*)DeleteDuplicates[Last/@jplist])};
Put[{1,{"res"->expr}},dir<>"/res"];
nd=Max[Count[Last@#,1]&/@jplist];
LiteRedMonitor[
While[jplist=!={},
(*\:043d\:0430\:0445\:043e\:0434\:0438\:043c hjsec*)
jsec=DeleteDuplicates[Last/@jplist];hjsec={Count[#,1],#}&@First@jsec;Scan[(t1={Count[#,1],#};If[OrderedQ[{hjsec,t1}],hjsec=t1])&,Rest@jsec];
{nd1,hjsec}=hjsec;hjsecn=hjsec(*{First@hjsec,FromDigits[Rest[List@@hjsec],2]}*);
(*\:0420\:0430\:0437\:0431\:0438\:0432\:0430\:0435\:043c \:043d\:0430 \:043f\:0430\:0441\:0441\:0438\:0432\:043d\:044b\:0439 \:0441\:043f\:0438\:0441\:043e\:043a \:0438 \:0430\:043a\:0442\:0438\:0432\:043d\:044b\:0439*)
If[MemberQ[ZeroSectors@First@hjsec,hjsec],
Put[{Replace[j@@hjsec,{1->(_?Positive),0->(_?NonPositive)},{1}]->0},dir<>"/"<>ToString[hjsecn]];
(*nr+=1;*)
jplist=DeleteCases[jplist,{_,hjsec}];
,
jlist=Cases[jplist,{x_,hjsec}:>x];jplist=DeleteCases[jplist,{_,hjsec}];
(*\:041f\:0440\:0438\:0432\:043e\:0434\:0438\:043c \:0438\:043d\:0442\:0435\:0433\:0440\:0430\:043b\:044b \:0441\:043b\:043e\:0436\:043d\:0435\:0439\:0448\:0435\:0433\:043e \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
rs0={};rs={};jplist1={};jrules=jExtRules@@hjsec/.PatternTest->(#1&);
If[Head@jrules===jExtRules||!er,
jrules=jRules@@hjsec/.PatternTest->(#1&)
];
t1=Length@jlist;
While[jlist=!={},
nrs=Replace[jlist,jrules,{1}];
rs0=Join[jlist,rs0];rs=Join[nrs,rs];
nr+=Length@jlist;
jlist={#,jsector@#}&/@DeleteDuplicates@Cases[{nrs}/.Dispatch[Thread[rs0->0]],_j,\[Infinity]];
jplist1=Join[jplist1,DeleteCases[jlist,{_,hjsec}]];
jlist=Cases[jlist,{x_,hjsec}:>x];
];
t2=Thread[rs0-> rs];
mis={mis,Cases[t2,HoldPattern[x_->x_]:>x]};
Put[{t1,t2},dir<>"/"<>ToString[hjsecn]];
AppendTo[jsd,hjsecn->((*{#1,FromDigits[{##2},2]}&@@@*)DeleteDuplicates[Last/@jplist1])];
jplist=Join[jplist,jplist1];
];
jplist=DeleteDuplicates@jplist;
]
,
TableForm[{{Overlay[{ProgressIndicator[nd-nd1,{0,nd}],nr},Alignment->Center]},{hjsec}}]
];
mis=Flatten@mis;
LiteRedPrintTemporary["MIs: ",mis];
nr1=0;
(*\:0411\:0435\:0440\:0435\:043c \:0432\:0441\:0435 \:043a\:043e\:043d\:0435\:0447\:043d\:044b\:0435 \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
LiteRedMonitor[
While[jsd=!={},
(*\:041d\:0435\:0437\:0430\:0432\:0438\:0441\:0438\:043c\:044b\:0435 \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
hjsec=Dispatch[Thread[First/@jsd->0]];
hjsec=MapThread[SameQ,{#,#/.hjsec}]&@jsd[[All,2]];
hjsec=Pick[jsd,hjsec,True];
jsd=Complement[jsd,hjsec];
(*SetSharedVariable[jsec,dir];
SetSharedFunction[j,js];
jsec={};Print[hjsec];*)
((*CriticalSection[{lock},jsec=Append[jsec,#1]]*)
jsec=#1;
{t2,jrules}=Get[dir<>"/"<>ToString[#1]];
t2=Append[Thread[First/@Take[jrules,-t2]->True],_j->False];
(*******************************************************)
(*status="Applying rules from "<>ToString[Length@#2]<>" lower sectors";*)
jrules=jrules/.Dispatch[Join@@(Get[dir<>"/"<>ToString[#]]&/@#2)];
(*status="Finished applying from lower sectors";*)
(*******************************************************)
(*\:0420\:0430\:0437\:0431\:0438\:0435\:043d\:0438\:0435 \:043d\:0430 \:0441\:0442\:0443\:043f\:0435\:043d\:0438*)
(*status="Layering sector";*)
(*\:0443\:0434\:0430\:043b\:044f\:0435\:043c \:0442\:0440\:0438\:0432\:0438\:0430\:043b\:044c\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0434\:043b\:044f \:043c\:0430\:0441\:0442\:0435\:0440\:043e\:0432*)
jrules={0,First@#,Cases[{Last@#},_j,\[Infinity]],#}&/@DeleteCases[jrules,HoldPattern[x_->x_]];
level[_]=0;
jrules=FixedPoint[{level[#2]=1+Max[0,level/@#3],##2}&@@@#&,jrules];
Clear[level];
jrules=Map[Last,SortBy[GatherBy[jrules,First],First[First@#]&],{2}];
(*status="Finished layering sector";*)
(*\:0420\:0430\:0441\:043f\:0443\:0442\:044b\:0432\:0430\:0435\:043c \:0441\:0435\:043a\:0442\:043e\:0440*)
jrules1={};
Scan[(
(*lvl++;*)
(*status="Substituing!";*)
t1=#/.Dispatch[jrules1];
(*status="Finished substituing!";*)
(*status="Collecting!";*)
t1=(#1->Collect[#2,_j,Together])&@@@t1;
jrules1=Join[jrules1,t1];
nr1+=Length@t1
(*status="Finished collecting!";*)
)&,
jrules
];
jrules=First/@jrules1/.t2;
Put[Pick[jrules1,jrules,True],dir<>"/"<>ToString[#1]];
(*CriticalSection[{lock},jsec=DeleteCases[jsec,#1]];*))&@@@hjsec;
],
TableForm[{{Overlay[{ProgressIndicator[nr1,{0,nr}],nr1},Alignment->Center]},{jsec}}]
];
res=Collect[Get[dir<>"/res"][[1,-1]]/.jc->j,_j,Factor],
res:=Abort[]
];
DeleteDirectory[dir,DeleteContents->True];
res
]]


ToMIsRule::usage = "ToMIsRule[j[\[Ellipsis]],j[\[Ellipsis]],...] gives a rule to pass to new master integrals.";


ToMIsRule[jlist_List]:=ToMIsRule@@jlist;
ToMIsRule[jjs___]:=Module[{nmis={jjs},l=Length[{jjs}],mis,mis1,rels,matr},
rels=IBPReduce[{jjs}];
mis=Sort[jVars[rels],Less];
matr=Outer[Coefficient,rels,mis];
If[MatrixRank@matr<l,Return[$Failed](*dependent*)];
mis1=mis;
While[
Length@matr<Length@mis,
matr=Append[matr,Coefficient[mis,First@mis1]];
If[MatrixRank@matr<Length@matr,matr=Most[matr],AppendTo[nmis,First@mis1]];
mis1=Rest@mis1;
];
Return[Collectj[Thread[mis->Inverse[matr].nmis],Factor]]
]


ToDShifts::usage="ToDShifts[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gets rid of numerators in \!\(\*
StyleBox[\"expr\", \"TI\"]\) at the expense of shifts of dimension. The result is a list {d-dimensional part,(d+2)-dimensional part with the replacement d\[Rule]d-2,(d+4)-dimensional part with the replacement d\[Rule]d-4,\[Ellipsis]}.\nSuch a form allows one to make a reduction prior to 'inverse' operator FromDShifts.";


ToDShifts[expr_List]:=(Message[ToDShifts::nolists];$Failed);
ToDShifts[expr_]:=Module[{
d=MetricTensor[],
s=0,t,r
},
r=Function[{jj,c},t=MapIndexed[(#1(c/.(d->d-2*First@#2+2)))&,todshifts[jj]];s=Max[s,Length@t];t]@@@CollectjList[expr];
Collectj[Plus@@(PadRight[#,s]&/@r)]
];


todshifts[jj:j[nm_,inds__Integer]]:=Module[
{
\[Nu]=MetricTensor[]/2,
L=Length@LMs@nm,
ninds,xs,nxs,ns,
G,gradG,
Plist
},
(*first, check if there is a need for the shift*)
xs=Table[Unique["x"],{Length@Ds@nm}];
ninds=Cases[{inds},_?Negative];
If[ninds=={},Return[{jj}]];
nxs=Pick[xs,{inds},_?Negative];(*don't forget about zero indices!*)
G=Plus@@FeynParUFFunction[nm]@@xs;
gradG=D[G,#]&/@nxs;
Plist={1};
MapIndexed[(Do[Plist=Prepend[Plist*gradG[[First@#2]],0]-Append[D[Plist,nxs[[First@#2]]],0],{-#1}])&,ninds];
(*a list of A-operators, should be untilded though*)
Plist=CoefficientRules[Rest@Plist/.Thread[Pick[xs,{inds},_?NonPositive]->0],xs];
ns=Replace[{inds},{_?Negative->0},{1}];
Prepend[MapIndexed[Function[{r,k},Plus@@((#2*(Pochhammer[(\[Nu]-First@k)(L+1)-Plus[inds],First@k*(L+1)-Plus@@#1+Plus@@ninds])*(Times@@Pochhammer[ns,#1])(j[nm,##]&@@(ns+#1)))&@@@r)],Plist],0]
];


FromDShifts::usage="FromDShifts[\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"expr0\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"expr1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"expr2\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\[Ellipsis]}] uses LoweringDRR to combine pieces from shifted dimensions. Up to the reduction, this operation is inverse of ToDShifts.";


FromDShifts[expr_List]:=Module[{d=MetricTensor[]},
Fold[Collectj[(#/.d->d+2/.j->LoweringDRR)+#2,Factor]&,0,Reverse@expr]
]


Factor1:=Cancel[Together[#]]&
Factor2:=((Factor[Numerator[#]]/Denominator[#])&@Together[#])&
Factor3:=((Factor[Numerator[#]]/Factor[Denominator[#]])&@Together[#])&


Collectj::usage="Collectj[\[ScriptE]\[ScriptX]\[ScriptP]\[ScriptR],\[ScriptF]] collects the \[ScriptE]\[ScriptX]\[ScriptP]\[ScriptR] with respect to j[\[Ellipsis]] applying the function \[ScriptF] to the coefficient.\n\ 
Collectj[\[ScriptE]\[ScriptX]\[ScriptP]\[ScriptR]] does the same with \[ScriptF] taken from the option \"SimplifyFunction\" of Collectj.";
Collectj::nonuniform="Non-uniform term detected: `1`";
jPattern::usage="jPattern\[Rule]\!\(\*
StyleBox[\"pattern\", \"TI\"]\) is an option for Collectj and CollectjList, which determines which structures should be treated.\n\
As of version 1.0, defaults to _j, reserved mainly for possible future needs.";


Options[Collectj]^={SimplifyFunction->Factor1,SimplifyAlways->True,jPattern->_j}


Collectj[expr_List,x___]:=Collectj[#,x]&/@expr;
Collectj[expr_Rule,x___]:=MapAt[Collectj[#,x]&,expr,2];
Collectj[expr_,OptionsPattern[]]:=Module[{sf,sa,freeterm,jterms,csow,jpat},
ReleaseHold[Hold[
csow[x_Plus,y_]:=csow[#,y]&/@x;
csow[x__*y_,z_]/;FreeQ[{x},jpat]:=csow[y,x*z];
csow[x:jpat,y_]:=(Sow[y,x];0);
(*csow[times[x___,y:jpat,x1___],z_]:=csow[y,x*x1*z];
csow[x_times,z_]:=csow[#2,#1*z]&@@SplitCases[Times@@x,{_?(FreeQ[#,jpat]&)}];*)
(*csow[times[x___,y_?(!FreeQ[#,jpat]&),x1___],z_]:=csow[y,x*x1*z];*)
csow[0,y_]:=0;
csow[x__?(FreeQ[#,jpat]&)*y_,z_]:=csow[y,x*z];
(*csow[times[x___?(FreeQ[#,jpat]&),y_,x1___?(FreeQ[#,jpat]&)],z_]:=csow[y,x*x1*z];*)
csow[x_,y_]:=(x*y)]/.jpat->OptionValue[jPattern]];
{sf,sa}={OptionValue@SimplifyFunction,OptionValue@SimplifyAlways};
{freeterm,jterms}=Reap[csow[expr(*/.Times\[Rule]times*),1],_j,({#1,#2})&](*/.times\[Rule]Times*);
If[freeterm=!=0,Message[Collectj::nonuniform,freeterm]];
freeterm+Plus@@(#1*If[sa,sf[Plus@@#2],If[Length@#2==1,First@#2,sf[Plus@@#2]]]&@@@jterms)];


Collectj[expr_,f_,opts:(_Rule|_RuleDelayed)...]:=Collectj[expr,SimplifyFunction->f,opts]


CollectjList::usage="CollectjList does the same as Collectj, but returns the result in the form of list {{j[\[Ellipsis]],\!\(\*
StyleBox[\"c1\", \"TI\"]\)},{j[\[Ellipsis]],\!\(\*
StyleBox[\"c2\", \"TI\"]\)},\[Ellipsis],\!\(\*
StyleBox[\"freeterm\", \"TI\"]\)}.";
CollectjList::nonuniform="Non-uniform term detected: `1`";


Options[CollectjList]^={SimplifyFunction->Factor1,SimplifyAlways->True,jPattern->_j,Sort->False}


CollectjList[expr_List,x___]:=CollectjList[#,x]&/@expr;
CollectjList[expr_,OptionsPattern[]]:=Module[{sf,sa,sort,freeterm,jterms,csow,jpat,res},
ReleaseHold[Hold[
csow[x_Plus,y_]:=csow[#,y]&/@x;
csow[x__*y_,z_]/;FreeQ[{x},jpat]:=csow[y,x*z];
csow[x:jpat,y_]:=(Sow[y,x];0);
(*csow[times[x___,y:jpat,x1___],z_]:=csow[y,x*x1*z];
csow[x_times,z_]:=csow[#2,#1*z]&@@SplitCases[Times@@x,{_?(FreeQ[#,jpat]&)}];*)
(*csow[times[x___,y_?(!FreeQ[#,jpat]&),x1___],z_]:=csow[y,x*x1*z];*)
csow[0,y_]:=0;
csow[x__?(FreeQ[#,jpat]&)*y_,z_]:=csow[y,x*z];
(*csow[times[x___?(FreeQ[#,jpat]&),y_,x1___?(FreeQ[#,jpat]&)],z_]:=csow[y,x*x1*z];*)
csow[x_,y_]:=(x*y)]/.jpat->OptionValue[jPattern]];
{sf,sa,sort}={OptionValue@SimplifyFunction,OptionValue@SimplifyAlways,OptionValue@Sort};
{freeterm,jterms}=Reap[csow[expr(*/.Times\[Rule]times*),1],_j,({#1,#2})&](*/.times\[Rule]Times*);
res=If[freeterm=!=0,Message[CollectjList::nonuniform,freeterm];Append[#,{1,freeterm}],
#]&[DeleteCases[{#1,If[sa,sf[Plus@@#2],If[Length@#2==1,First@#2,sf[Plus@@#2]]]}&@@@jterms,{_,0}]];
If[TrueQ@sort,Sort[res,Less[First@#1,First@#2]&],res]
];


CollectjList[expr_,f_,opts:(_Rule|_RuleDelayed)...]:=CollectjList[expr,SimplifyFunction->f,opts]


AttachGraph::usage="AttachGraph[js[\[Ellipsis]],{{1\[Rule]2,\"\"},{2\[Rule]3,\"M\"},\[Ellipsis]}] attaches the graph to some sector. This attachment determines also the \
graphs of the subsectors. The number of edges should be equal or greater than the number of 1s in the topology. \
The external legs should be indicated in the end of the list as {0\[Rule]n,_}.";


AttachGraph[js[nm_,x:(0|1)..],g_List]:=Module[{},
If[Count[{x},1]>Length[g],Message[AttachGraph::usage];Abort[]];
nm/:jGraph[nm]=Sort[Append[DeleteCases[jGraph[nm],js[nm,x]->_],js[nm,x]->g],First[#1]<First[#2]&];
]


jGraph::usage="jGraph[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives all graphs connected with the basis.\n\
jGraph[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)]] gives the graph corresponding to the sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)].\n\
jGraph[j[\[Ellipsis]]]  gives the graph corresponding to the integral.\n\ 
Use GraphPlot[jGraph[j[\[Ellipsis]]]] to draw a graph.";
jGraph::nograph="No graph, sorry.";
jGraph::nums="The numerator is not drawn!.";


Options[jGraph]={Number->False};


jGraph[_Symbol]:={};


jGraph[js[nm_,x:(0|1)..],OptionsPattern[]]:=Module[{graph=None,jsect=jSector[j[nm,x]],contracted,newv,tmp,edge,i=0},
Catch[Scan[(If[jsect<=First[#],
contracted=Reverse@Sort@Flatten@Position[DeleteCases[Rest[List@@jsect+List@@First[#]],0],1,{1}];
graph=Last[#];
If[OptionValue[Number],
MapIndexed[(graph[[First@#2,2]]={First@#1,graph[[First@#2,2]]})&,Position[Rest[List@@First@#],1]]
];
Throw[graph]])&,
jGraph[nm]
]];
If[graph===None,Message[jGraph::nograph];Return[]];
(*Now we contract all lines*)
Scan[(graph=Function[{e,l},{e/.(graph[[#,1]]/.(DirectedEdge|UndirectedEdge)->Rule),l}]@@@Delete[graph,#])&,contracted];
graph/.{0:>(--i)}
]


jGraph[j[nm_,x__],OptionsPattern[]]:=Module[{graph=None,jsect=jSector[j[nm,x]],contracted,newv,tmp,edge,i=0},
Catch[Scan[(If[jsect<=First[#],
contracted=Reverse@Sort@Flatten@Position[DeleteCases[Rest[List@@jsect+List@@First[#]],0],1,{1}];
graph=Last[#];
If[OptionValue[Number],
MapIndexed[(graph[[First@#2,2]]={First@#1,graph[[First@#2,2]]})&,Position[Rest[List@@First@#],1]]
];
Throw[graph]])&,
jGraph[nm]
]];
If[graph===None,Message[jGraph::nograph];Return[]];
(*Now we contract all lines*)
Scan[(graph=Function[{e,l},{e/.(graph[[#,1]]/.(DirectedEdge|UndirectedEdge)->Rule),l}]@@@Delete[graph,#](*Delete[graph,#]/.Switch[graph[[#]],(_Rule|_DirectedEdge|_UndirectedEdge),
graph[[#]]/.(DirectedEdge|UndirectedEdge)->Rule,{(_Rule|_DirectedEdge|_UndirectedEdge),_},graph[[#,1]]/.(DirectedEdge|UndirectedEdge)->Rule]*))&,contracted];
(*Now we need to put dots*)
newv=Max[Cases[graph,_Rule,\[Infinity]]/.Rule->Sequence]+1;(*unique new vertex index*)
MapIndexed[(For[tmp=#1,tmp>1,tmp--,AppendTo[graph,graph[[First[#2]]]/.{HoldPattern[Rule[v1_,v2_]]:>(Rule[newv,v2])}];
graph[[First[#2]]]=graph[[First[#2]]]/.{HoldPattern[Rule[v1_,v2_]]:>(Rule[v1,newv++])};
])&,DeleteCases[{x},0]];
If[Cases[{x},_?Negative]!={},Message[jGraph::nums]];
graph/.{0:>(--i)}
]


FeynParUF::usage="FeynParUF[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list {\!\(\*
StyleBox[\"U\", \"TI\"]\),\!\(\*
StyleBox[\"F\", \"TI\"]\),\!\(\*
StyleBox[\"xs\", \"TI\"]\)}, where \!\(\*
StyleBox[\"U\", \"TI\"]\) and \!\(\*
StyleBox[\"F\", \"TI\"]\) are the polynomials, entering the Feynman parametrization of the integrals in the highest sector  of the basis.\nFeynParUF[js[\[Ellipsis]]] gives \!\(\*
StyleBox[\"U\", \"TI\"]\) and \!\(\*
StyleBox[\"F\", \"TI\"]\) polynomials, entering the Feynman parametrization of the integrals in the given sector, and \!\(\*
StyleBox[\"xs\", \"TI\"]\) are the Feynman parameters.\nFeynParUF[{\!\(\*
StyleBox[\"dens\", \"TI\"]\)},{\!\(\*
StyleBox[\"lms\", \"TI\"]\)}] does the same for the integrals with denominators {\!\(\*
StyleBox[\"dens\", \"TI\"]\)} and loop momenta {\!\(\*
StyleBox[\"lms\", \"TI\"]\)}.";


Options[FeynParUF]={NamingFunction->(Array[ToExpression["x"<>ToString[#]]&,{#}]&),PolyNForm->False};


FeynParUF::valued="The parameters names `1` seem to be occupied.\n\
Use NamingFunction\[Rule](Table[Unique[],{#}]&) option if you want to be guaranted from this.";


FeynParUF[nm_Symbol,opts:OptionsPattern[]]:=FeynParUF[js@@Prepend[ConstantArray[1,{Length@Ds@nm}],nm],opts]


FeynParUF[js[nm_,x:(1|0)...],OptionsPattern[]]:=Module[
{xs,lms=LMs@nm,ds=Ds@nm,den,t1,t2,dt2,a},
xs=OptionValue[NamingFunction][Count[{x},1],{x}];
(*If[Or@@ValueQ/@xs,Message[FeynParUF::valued,Select[xs,ValueQ]]];*)
Declare[Evaluate@xs,Number];
den=Collect[LFDistribute[xs.Pick[ds,{x},1],_sp],_sp];
t1=(D[den,#]/2/.{Derivative[0,1][sp]:>(#1&),Derivative[1,0][sp]:>(#2&)})&/@lms;
t2=(D[t1,#])&/@lms;
t1=t1/.Thread[lms->0];
dt2=Factor[Det[t2]];
If[dt2==0,Return[{0,0,xs}]];
t2=Together[(dt2*den/.Thread[lms->0])-LFDistribute@Inner[sp,t1,Together[dt2*Inverse[t2]].t1,Plus]];
If[OptionValue[PolyNForm],
Append[CoefficientList[PolyNForm[dt2+a*t2,xs],a],xs]
,
{dt2,t2,xs}]
]


FeynParUF[dsl_List,lms_List,OptionsPattern[]]:=Module[
{xs,ds=Flatten@dsl,den,t1,t2,dt2,a},
xs=OptionValue[NamingFunction][Length@ds,1&/@ds];
Declare[Evaluate@xs,Number];
den=Collect[LFDistribute[xs.ds,_sp],_sp];
t1=(D[den,#]/2/.{Derivative[0,1][sp]:>(#1&),Derivative[1,0][sp]:>(#2&)})&/@lms;
t2=(D[t1,#])&/@lms;
t1=t1/.Thread[lms->0];
dt2=Factor[Det[t2]];
If[dt2==0,Return[{0,0,xs}]];
t2=Together[(dt2*den/.Thread[lms->0])-LFDistribute@Inner[sp,t1,Together[dt2*Inverse[t2]].t1,Plus]];
{dt2,t2,Unflatten[xs,dsl]}
]


FeynParUFFunction::usage="FeynParUFFunction[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives, as a pure function, the list {\!\(\*
StyleBox[\"U\", \"TI\"]\),\!\(\*
StyleBox[\"F\", \"TI\"]\)} of polynomials, entering the Feynman parametrization of the integrals in the highest sector  of the basis.\nFeynParUFFunction[js[\[Ellipsis]]] gives \!\(\*
StyleBox[\"U\", \"TI\"]\) and \!\(\*
StyleBox[\"F\", \"TI\"]\) polynomials, entering the Feynman parametrization of the integrals in the given sector.\nFeynParUFFunction[{\!\(\*
StyleBox[\"dens\", \"TI\"]\)},{\!\(\*
StyleBox[\"lms\", \"TI\"]\)}] does the same for the integrals with denominators {\!\(\*
StyleBox[\"dens\", \"TI\"]\)} and loop momenta {\!\(\*
StyleBox[\"lms\", \"TI\"]\)}.";


Options[FeynParUFFunction]={PolyNForm->False};


FeynParUFFunction[args__,opts:OptionsPattern[]]:=Module[{u,f,xs,function},
{u,f,xs}=FeynParUF[args,opts,NamingFunction->(Table[Unique[],{#}]&)];
function[{u,f}/.Thread[xs->Array[Slot,Length@xs]]]/.function->Function
]


GramP::usage="GramP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives Gram polynomial G(\!\(\*SubscriptBox[
StyleBox[\"l\", \"TI\"], \(1\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"l\", \"TI\"], \(L\)]\),\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(1\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(E\)]\)) expressed in terms of denominators."


Options[GramP]={NamingFunction->(Array[ToExpression["d"<>ToString[#]]&,{#}]&),PolyNForm->False};


GramP::valued="The parameters names `1` seem to be occupied.\n\
Use NamingFunction\[Rule](Table[Unique[],{#}]&) option if you want to be guaranted from this.";


GramP[jsec_js,opts:OptionsPattern[]]:=Module[{poly,ds},
{poly,ds}=GramP[First@jsec,opts];
{Factor[poly/.Thread[Pick[ds,Rest@jsec,1]->0]],Pick[ds,Rest@jsec,0]}
];
GramP[nm_,OptionsPattern[]]:=Module[
{ds,qs,res},
ds=OptionValue[NamingFunction][Length@Ds[nm]];
Declare[Evaluate@ds,Number];
qs=Join[LMs[nm],EMs[nm]];
res=Det[Outer[sp,qs,qs]]/.Thread[SPs[nm]->Toj[nm,SPs[nm]]/.{j[nm,0...]->1,j[nm,x__]:>ds[[1+LengthWhile[{x},#===0&]]]}];
If[OptionValue[PolyNForm],
{PolyNForm[res,ds],ds}
,
{res,ds}]
];


GramPFunction::usage="GramPFunction[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a Gram polynomial G(\!\(\*SubscriptBox[
StyleBox[\"l\", \"TI\"], \(1\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"l\", \"TI\"], \(L\)]\),\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(1\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(E\)]\)) as a a pure function  of denominators."


Options[GramPFunction]={PolyNForm->False};


GramPFunction[expr_,opts:OptionsPattern[]]:=Module[{gp,ds,function},
{gp,ds}=GramP[expr,opts,NamingFunction->(Table[Unique[],{#}]&)];
function[gp/.Thread[ds->Array[Slot,Length@ds]]]/.function->Function
]


PolyVPInv::usage="PolyVPInv[\!\(\*
StyleBox[\"poly\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)] gives an invariant of the polynomial which does not change at any permutation of its variables.\n\ 
This invariant has the form of the list: {\!\(\*
StyleBox[\"coefs\", \"TI\"]\),{\!\(\*
StyleBox[\"ind1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"ind2\", \"TI\"]\)\[Ellipsis]},\!\(\*
StyleBox[\"b\", \"TI\"]\)}.\n\
First parameter \!\(\*
StyleBox[\"coefs\", \"TI\"]\) is a list of coefficients. \
Each \!\(\*
StyleBox[\"ind1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"ind2\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\) unambiguously describes the power of one variable in each monomial. \
The list of these powers can be obtained as IntegerDigits[\!\(\*
StyleBox[\"ind\", \"TI\"]\),\!\(\*
StyleBox[\"b\", \"TI\"]\),Length@\!\(\*
StyleBox[\"coefs\", \"TI\"]\)].";


PolyVPInv[poly_,vars_]:=First@polyNF[poly,vars](*MapAt[Last/@#&,First@polyNF[poly,vars],{2}]*);


PolyNForm::usage="PolyNForm[\!\(\*
StyleBox[\"poly\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)] permutes the variables to some canonical order, \
so that if two polynomials \!\(\*
StyleBox[\"poly1\", \"TI\"]\) and \!\(\*
StyleBox[\"poly2\", \"TI\"]\) are equivalent up to notations, then PolyNForm[\!\(\*
StyleBox[\"poly1\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)]===PolyNForm[\!\(\*
StyleBox[\"poly2\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)].\n\
PolyNForm->True is also an option for FeynParUF, which results in normal form naming of the Feynman parameters.";


PolyNForm[poly_,vars_]:=poly/.Thread[(*polyNF[poly,vars]\[LeftDoubleBracket]1,2,All,1\[RightDoubleBracket]*)polyNF[poly,vars][[-1,1]]->vars];


PolyMapToVPInv::usage="PolyMapToVPInv[\!\(\*
StyleBox[\"poly\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\),{\!\(\*
StyleBox[\"coefs\", \"TI\"]\),{\!\(\*
StyleBox[\"ind1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"ind2\", \"TI\"]\)\[Ellipsis]},\!\(\*
StyleBox[\"b\", \"TI\"]\)}] tries to find a correspondance \!\(\*
StyleBox[\"vars\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\){\!\(\*
StyleBox[\"ind1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\*
StyleBox[\(\!\(\*
StyleBox[\"ind2\", \"TI\"]\)\[Ellipsis]\)]} for which \!\(\*
StyleBox[\"poly\", \"TI\"]\) has an invariant {\!\(\*
StyleBox[\"coefs\", \"TI\"]\),{\!\(\*
StyleBox[\"ind1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\*
StyleBox[\(\!\(\*
StyleBox[\"ind2\", \"TI\"]\)\[Ellipsis]\)]},\!\(\*
StyleBox[\"b\", \"TI\"]\)}";


PolyMapToVPInv[p_,vars_,{coefs1_List,inds_List,b1_Integer}]:=If[#==={},$Failed,#[[1,2]]]&[polyMapToInv[p,vars,{coefs1,inds,b1}]];


LoweringDRR::usage="LoweringDRR[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]] gives a dimensional recurrence lowering the dimension of the integral. 
The result is the expression of j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]] in d+2 dimensions via the integrals in d dimensions.\n\
The loop integration measure is chosen as \!\(\*SuperscriptBox[\(d\), \(d\)]\)l/\!\(\*SuperscriptBox[\(\[Pi]\), \(d/2\)]\).";


LoweringDRR[nm_,inds__]:=Module[{lms=LMs@nm,l,ems=EMs@nm,e,v,d=MetricTensor[]},
l=Length@lms;e=Length@ems;
v=If[e==0,1,Det[Outer[sp,EMs@nm,EMs@nm]]];
2^l/(v Pochhammer[d-e-l+1,l])*Expand[j[nm,inds]*(Det[Outer[sp,Join[lms,ems],Join[lms,ems]]]/.Toj[nm])]
]


RaisingDRR::usage="RaisingDRR[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]] gives a dimensional recurrence raising the dimension of the integral. 
The result is the expression of j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]] in d-2 dimensions via the integrals in d dimensions.\n\
The loop integration measure is chosen as \!\(\*SuperscriptBox[\(d\), \(d\)]\)l/\!\(\*SuperscriptBox[\(\[Pi]\), \(d/2\)]\).";


RaisingDRR[nm_,inds__]:=Module[{l=Length@LMs@nm,dim=Length@Ds[nm],a,i,k,\[Beta]s,\[Beta]s1,A},
a=Array[A,{dim}];
Expand[Det[Table[(If[i==k,1,1/2]*Coefficient[#,sp[LMs[nm][[i]],LMs[nm][[k]]]]&/@LFDistribute[Ds[nm]]).a,{i,l},{k,l}]]*j[nm,inds]]
//.{A[i_]^k_.*j[nm,\[Beta]s__]:>(\[Beta]s1={\[Beta]s};\[Beta]s1[[i]]+=k;Pochhammer[{\[Beta]s}[[i]],k]j[nm,##]&@@\[Beta]s1)}
];


Dinv::usage="Dinv[\!\(\*
StyleBox[\"expr\", \"TI\"]\),p\[CenterDot]q] is the differentiation of \!\(\*
StyleBox[\"expr\", \"TI\"]\) with respect to p\[CenterDot]q. It assumes, that other scalar products of the external momenta are constants. \
Pay attention that p\[CenterDot]q and q\[CenterDot]p is not exactly the same in the second argument. If p\[CenterDot]q is used, the derivative of j[...] is expressed in terms of \[PartialD]/\[PartialD]p.\n\
Explicit scalar functions of p\[CenterDot]q are differentiated correctly, unless p\[CenterDot]q is evaluated to something.\nDinv[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the derivative of \!\(\*
StyleBox[\"expr\", \"TI\"]\) with respect to the variable \!\(\*
StyleBox[\"x\", \"TI\"]\).";


SetAttributes[Dinv,{HoldAll}];


Dinv[j1_j,sp[(p_?VecVarQ),(q_?VecVarQ)]]:=Module[{pq,em,nm,djdp},
nm=First@j1;
em=DeleteDuplicates[Join[{p,q},EMs@nm]];
djdp=(D[Fromj[j1],p]/.{Derivative[1,0][sp][a_,b_]:>b,Derivative[0,1][sp][a_,b_]:>a});
Toj[nm,If[p=!=q,1,1/2]*(sp[#,djdp]&/@em).Inverse[Outer[sp,em,em]].D[em,q]]
]


Dinv[expr_,sp[(p_?VecVarQ),(q_?VecVarQ)]]:=Module[{pq,em,nm,j1},
D[LFDistribute[expr,sp]/.sp[p,q]->pq,pq,NonConstants->jVars[expr]]/.
{HoldPattern[D[j1_j,pq,NonConstants->{___,j1_,___}]]:>Dinv[j1,sp[p,q]]}/.pq->sp[p,q]
]


Dinv[expr_,s_Symbol]:=Module[{ems},
ems=Union@@EMs/@Union[First/@jVars[expr]];
D[expr,s,NonConstants->jVars[expr]]/.HoldPattern[D[jj_j,s,NonConstants->_]]:>(Toj[First@jj,D[Fromj[jj],s]]+Plus@@(Dinv[jj,sp[##]]*D[sp[##],s]&@@@Replace[Subsets[ems,{1,2}],{x_}:>{x,x},{1}]))
];


csow[x_Plus,y_]:=csow[#,y]&/@x;
csow[x__*y_j,z_]/;FreeQ[{x},_j]:=csow[y,x*z];
(*csow[times[x___,y_j,x1___],z_]:=csow[y,x*x1*z];
csow[x_times,z_]:=csow[#2,#1*z]&@@SplitCases[Times@@x,{_?(FreeQ[#,_j]&)}];*)
csow[times[x___,y_?(!FreeQ[#,_j]&),x1___],z_]:=csow[y,x*x1*z];
csow[x_j,y_]:=(Sow[y,x];0);
csow[0,y_]:=0;
csow[x__?(FreeQ[#,_j]&)*y_,z_]:=csow[y,x*z];
csow[x_,y_]:=(x*y);
(*csow[times[x___?(FreeQ[#,_j]&),y_,x1___?(FreeQ[#,_j]&)],z_]:=csow[y,x*x1*z];*)


sid[ids_,id_]:=sid[ids,id,Highj[id]];
sid[ids_List,id_,jj_j]:=sid[#,id,jj]&/@ids;
sid[id1_,id_,jj_j]:=Module[{
c1=Coefficient[id1,jj],
c=Coefficient[id,jj],
vars=Alternatives@@Variables[Rest[List@@jj]]
},
If[jj==={},Return[id1]];(*no j needs to be canceled*)
If[c1===0,Return[id1]](*already no jj*);
Assert[c=!=0];
{c,c1}={Numerator@#,Denominator@#}&[Factor[c/c1]];
If[FreeQ[{c,c1},vars],
Return[Collect[(c*id1-c1*id),_j,Factor]],
Return[id1]
]
];
sharpen[ids0_List]:=Module[{
ids=ids0,idsr={},id,
hj,
i
},
While[(hj=Highj@ids)=!={},
{{i}}=Position[ids,_?(Not[FreeQ[#,hj]]&),{1},1];(*definitely exists*)
id=ids[[i]];
ids=sid[Delete[ids,i],id,hj];
idsr=Prepend[sid[ idsr,id,hj],id];
];
Return[idsr]
];


jsectlt[x1_List]:=x1=!=(0&/@x1)&&Not[Or@@Positive[x1]];
jsectle[x1_List]:=Not[Or@@Positive@x1];
jsectgt[x1_List]:=x1=!=(0&/@x1)&&Not[Or@@Negative@x1];
jsectge[x1_List]:=Not[Or@@Negative@x1];


nfGraph[g_]:=Module[
{vs,gn=g/._Integer?NonPositive->0},
vs=Sort@Union[Sequence@@@First/@gn];
gn/.Thread[vs->Range[0,Length@vs-1]]
]


toNickel[g_]:=Module[
{vs,vs1,v,v1,et,e1,t={},h},
vs1=Sort@Union[Sequence@@@First/@g,{0}];
et=Sort@Union@(Last/@g);
While[vs1=!={},
v=First@vs1;t={t,h@@Map[Sort[Cases[g,{(Rule|RightArrow|LeftRightArrow|UndirectedEdge)[v,v1_],#}|{(Rule|UndirectedEdge)[v1_,v],#}/;MemberQ[vs1,v1]:>v1]]&,et]};vs1=Rest@vs1;
];Flatten@t/.h->List
]


fromNickel[nickel_]:=Sort@Flatten[MapIndexed[Function[{etl,ind},MapIndexed[Function[{vl,et},{First@ind-1->#,ToExpression["e"<>ToString[First@et]]}&/@vl],etl]],nickel],2]


cfNickel[nickel_]:=Module[{p,f=0,f1,s,g,i,t,t1,cand={nickel}},
Do[
cand=First/@First@SplitBy[SortBy[{#,signature[Join[#[[p]],List/@Range[f]]]}&/@cand,Last],Last];
(*\:0432\:044b\:0431\:0438\:0440\:0430\:0435\:043c \:043f\:043e \:0434\:043b\:0438\:043d\:0430\:043c, \:0430\:043a\:043a\:0443\:0440\:0430\:0442\:043d\:043e \:0443\:0447\:0438\:0442\:044b\:0432\:0430\:044f \:0434\:0443\:0431\:043b\:0438\:043a\:0430\:0442\:044b.*)
f1=f;f+=Length[DeleteCases[DeleteDuplicates@Flatten@cand[[1,p]],_?(#<=f&)]];
If[f>=p,t1=Range[f1+1,f];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand[[i,p]],_?(#<=f1&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand[[i]]=(fromNickel[cand[[i]]]/.t);
cand[[i]]=toNickel/@cand[[i]];
,{i,Length@cand}],
Do[
t={#->p,p->#}&/@Range[p,Length@nickel-1];
cand[[i]]=(fromNickel[cand[[i]]]/.t);
cand[[i]]=toNickel/@cand[[i]];
,{i,Length@cand}];f=p
];
cand=Union@@cand
,{p,Length@nickel-1}];
First@cand
]


cfGraph[graph_]:=Module[
{nick=toNickel@graph,p,f=0,f1,g,i,t,t1,cand},
cand={g[nick,graph]};
Do[
cand=First/@First@SplitBy[SortBy[{#,signature[Join[First[#][[p]],List/@Range[f]]]}&/@cand,Last],Last];
(*\:0432\:044b\:0431\:0438\:0440\:0430\:0435\:043c \:043f\:043e \:0434\:043b\:0438\:043d\:0430\:043c, \:0430\:043a\:043a\:0443\:0440\:0430\:0442\:043d\:043e \:0443\:0447\:0438\:0442\:044b\:0432\:0430\:044f \:0434\:0443\:0431\:043b\:0438\:043a\:0430\:0442\:044b.*)
f1=f;f+=Length[DeleteCases[DeleteDuplicates@Flatten@cand[[1,1,p]],_?(#<=f&)]];
If[f>=p,t1=Range[f1+1,f];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand[[i,1,p]],_?(#<=f1&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand[[i]]=(cand[[i,2]]/.t);
cand[[i]]={toNickel@#1,#1}&/@cand[[i]];
,{i,Length@cand}],
Do[
t={#->p,p->#}&/@Range[p,Length@nick-1];
cand[[i]]=(cand[[i,2]]/.t);
cand[[i]]={toNickel@#1,#1}&/@cand[[i]];
,{i,Length@cand}];f=p
];
cand=Union@@cand
,{p,Length@nick-1}];
Sort[({Sort[#1],#2}&@@@Last[#])&@First@cand]
]


automorphisms[graph_]:=Module[
{nick=toNickel@graph,gr={Sort[#1],#2}&@@@graph,vs=Sort@Union[Sequence@@@First/@graph,{0}],p,f=0,f1,g,i,t,t1,cand},
cand={g[nick,vs,graph]};
Do[
cand=First/@First@SplitBy[SortBy[{#,signature[Join[First[#][[p]],List/@Range[f]]]}&/@cand,Last],Last];
(*\:0432\:044b\:0431\:0438\:0440\:0430\:0435\:043c \:043f\:043e \:0434\:043b\:0438\:043d\:0430\:043c, \:0430\:043a\:043a\:0443\:0440\:0430\:0442\:043d\:043e \:0443\:0447\:0438\:0442\:044b\:0432\:0430\:044f \:0434\:0443\:0431\:043b\:0438\:043a\:0430\:0442\:044b.*)
f1=f;f+=Length[DeleteCases[DeleteDuplicates@Flatten@cand[[1,1,p]],_?(#<=f&)]];
If[f>=p,
t1=Range[f1+1,f];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand[[i,1,p]],_?(#<=f1&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand[[i]]=(cand[[i,{2,3}]]/.t);
cand[[i]]=g[toNickel@#2,#1,#2]&@@@cand[[i]];
,{i,Length@cand}],
Do[
t={#->p,p->#}&/@Range[p,Length@nick-1];
cand[[i]]=(cand[[i,{2,3}]]/.t);
cand[[i]]=g[toNickel@#2,#1,#2]&@@@cand[[i]];
,{i,Length@cand}];f=p
];
cand=Union@@cand
,{p,Length@nick-1}];
cand={#2,System`Permute[Range[Length[graph]],FindPermutation[{Sort[#1],#2}&@@@#3]]}&@@@cand;
g=Thread/@MapThread[Rule,{cand[[1]],{vs,Range[Length[graph]]}}];
MapThread[Thread[#->#2]&,{{vs,Range[Length[graph]]},MapThread[ReplaceAll[##]&,{#,g}]}]&/@cand
]


isomorphisms[graph1_,graph2_]:=Module[
{nick1=toNickel@graph1,nick2=toNickel@graph2,
gr1={Sort[#1],#2}&@@@graph1,gr2={Sort[#1],#2}&@@@graph2,
vs1=Sort@Union[Sequence@@@First/@graph1,{0}],vs2=Sort@Union[Sequence@@@First/@graph2,{0}],
cand1,cand2,
p,f=0,h,h2,g,i,t,t1},
If[vs1=!=vs2,Return[{}]];
cand1={g[nick1,vs1,graph1]};cand2={g[nick2,vs2,graph2]};
Catch[Do[
cand1=First@SplitBy[SortBy[{#,signature[Join[First[#][[p]],List/@Range[f]]]}&/@cand1,Last],Last];
cand2=First@SplitBy[SortBy[{#,signature[Join[First[#][[p]],List/@Range[f]]]}&/@cand2,Last],Last];
(*\:0432\:044b\:0431\:0438\:0440\:0430\:0435\:043c \:043f\:043e \:0434\:043b\:0438\:043d\:0430\:043c, \:0430\:043a\:043a\:0443\:0440\:0430\:0442\:043d\:043e \:0443\:0447\:0438\:0442\:044b\:0432\:0430\:044f \:0434\:0443\:0431\:043b\:0438\:043a\:0430\:0442\:044b.*)
If[cand1[[1,-1]]=!=cand2[[1,-1]],Throw[{}]];
cand1=First/@cand1;
cand2=First/@cand2;
h=f;f+=Length[DeleteCases[DeleteDuplicates@Flatten@cand1[[1,1,p]],_?(#<=f&)]];
If[f>=p,
t1=Range[h+1,f];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand1[[i,1,p]],_?(#<=h&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand1[[i]]=(cand1[[i,{2,3}]]/.t);
cand1[[i]]=g[toNickel@#2,#1,#2]&@@@cand1[[i]];
,{i,Length@cand1}];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand2[[i,1,p]],_?(#<=h&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand2[[i]]=(cand2[[i,{2,3}]]/.t);
cand2[[i]]=g[toNickel@#2,#1,#2]&@@@cand2[[i]];
,{i,Length@cand2}]
,
t={#->p,p->#}&/@Range[p,Length@nick1-1];
Do[
(**\:0412\:044b\:043d\:0435\:0441\:0442\:0438 \:0438\:0437-\:043f\:043e\:0434 \:0446\:0438\:043a\:043b\:0430!!!**)
cand1[[i]]=(cand1[[i,{2,3}]]/.t);
cand1[[i]]=g[toNickel@#2,#1,#2]&@@@cand1[[i]];
,{i,Length@cand1}];
Do[
cand2[[i]]=(cand2[[i,{2,3}]]/.t);
cand2[[i]]=g[toNickel@#2,#1,#2]&@@@cand2[[i]];
,{i,Length@cand2}];f=p
];
cand1=Union@@cand1;
cand2=Union@@cand2;
,{p,Length@nick1-1}];
cand1={#2,System`Permute[Range[Length[graph1]],FindPermutation[{Sort[#1],#2}&@@@#3]]}&@@@cand1;
g=Thread/@MapThread[Rule,{{#2,System`Permute[Range[Length[graph2]],FindPermutation[{Sort[#1],#2}&@@@#3]]}&@@cand2[[1]],{vs1,Range[Length[graph2]]}}];
MapThread[Thread[#1->#2]&,{{vs1,Range[Length[graph2]]},MapThread[ReplaceAll[##]&,{#,g}]}]&/@cand1
]
]


signature[set_List]:=Sort[Outer[Count[#2,#1]&,DeleteDuplicates@Flatten@set,set,1]];
(*signature[set_List]:=Sort[Function[v,FromDigits[Boole[MemberQ[#,v]]&/@set,2]]/@DeleteDuplicates@Flatten@set];*)
permutations[set_List]:=Module[{h},Flatten[Outer[h@@Join[##]&,##,1]&@@Permutations/@Map[First,GatherBy[Function[v,{v,Count[#,v]&/@set}]/@DeleteDuplicates@Flatten@set,Last],{2}]]/.h->List];
permutations[{{}...}]:={{}};


Options[polyNF]={Monitor->False};
polyNF[p_]:=polyNF[p,Variables[p]];
polyNF[p_,vars_List]:=Module[
{cand,coefs,candn,nt,b,crit,n,k,i,c,c1,fc,t,rfc,lfc,vt,vt1,vt2,ct},
b=Max[Exponent[p,vars]]+1;(*\:0431\:0430\:0437\:0430 \:0434\:043b\:044f \:043a\:043e\:0434\:0438\:0440\:043e\:0432\:0430\:043d\:0438\:044f*)
cand=CoefficientRules[p,vars];nt=Length@cand;
crit=Function[x,{-Plus@@(First@x^#)&/@Range[b-1],Last@x}];
(*\:043f\:0435\:0440\:0432\:0438\:0447\:043d\:044b\:0439 \:043a\:0440\:0438\:0442\:0435\:0440\:0438\:0439 \[LongDash] {{\:0441\:0443\:043c\:043c\:0430 \:0441\:0442\:0435\:043f\:0435\:043d\:0435\:0439,\:0441\:0443\:043c\:043c\:0430 \:043a\:0432\:0430\:0434\:0440\:0430\:0442\:043e\:0432 \:0441\:0442\:0435\:043f\:0435\:043d\:0435\:0439, \:0438 \:0442.\:0434.},\:043a\:043e\:044d\:0444\:0444\:0438\:0446\:0438\:0435\:043d\:0442}*)
cand=SplitBy[SortBy[cand,crit],crit];
coefs=Flatten@cand/.Rule->(#2&);
cand=cand/.Rule->(#1&);
vt=0&/@vars;(*\:0442\:0438\:043f\:044b \:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:044b\:0445, \:0438\:043d\:0438\:0446\:0438\:0430\:043b\:0438\:0437\:0438\:0440\:043e\:0432\:0430\:043d\:043d\:044b\:0435 \:0432 \:043d\:043e\:043b\:044c, \:0442.\:0435. \:0441\:043d\:0430\:0447\:0430\:043b\:0430 \:0432\:0441\:0435 \:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:044b\:0435 \:0440\:0430\:0432\:043d\:044b*)
cand={Append[cand,vt]};(*\:041f\:043e\:0441\:043b\:0435\:0434\:043d\:0438\:0439 \:0430\:0440\:0433\:0443\:043c\:0435\:043d\:0442 \[LongDash] \:0441\:043f\:0438\:0441\:043e\:043a \:0442\:0438\:043f\:043e\:0432*)(*\:0441 \:044d\:0442\:043e\:0433\:043e \:043c\:043e\:043c\:0435\:043d\:0442\:0430 \:043a\:0430\:0436\:0434\:044b\:0439 \:0438\:0437 \:043a\:0430\:043d\:0434\:0438\:0434\:0430\:0442\:043e\:0432 \[LongDash] \:0441\:043f\:0438\:0441\:043e\:043a \:043c\:043e\:043d\:043e\:043c\:043e\:0432, \:0440\:0430\:0437\:0431\:0438\:0442\:044b\:0439 \:043f\:043e \:043a\:0440\:0438\:0442\:0435\:0440\:0438\:044e \:0438  \:0434\:043e\:043f\:043e\:043b\:043d\:0435\:043d\:043d\:044b\:0439 \:0441\:043f\:0438\:0441\:043a\:043e\:043c \:0442\:0438\:043f\:043e\:0432*)
Do[
vt=b*(vt+1);
candn={};
Scan[
Function[c,
fc=First@c;lfc=Length@fc;
Do[
vt1=b*Last@c+fc[[i]];
vt2=Reverse@Sort@vt1;
If[!OrderedQ[{vt,vt2}],
vt=vt2;candn={ReplacePart[c,{1:>Replace[Delete[fc,i],{}->Sequence[]],-1->vt1}]},If[vt===vt2,AppendTo[candn,ReplacePart[c,{1:>Replace[Delete[fc,i],{}->Sequence[]],-1->vt1}]]]
]
,{i,lfc}];
]
,cand];
cand=candn
,{n,nt}];
{{coefs,vt,b},Reverse[vars[[Ordering[Last@#]]]]&/@cand}
];


polyMapToInv[p_,vars_,{coefs1_List,inds_List,b1_Integer}]:=Module[
{cand,coefs,candn,nt,b,crit,n,k,i,c,c1,fc,t,rfc,lfc,vt,vt1,vt2,ct},
b=Max[Exponent[p,vars]]+1;
If[b=!=b1,Return[{}]];
cand=CoefficientRules[p,vars];nt=Length@cand;
crit=Function[x,{-Plus@@(First@x^#)&/@Range[b-1],Last@x}];
cand=SplitBy[SortBy[cand,crit],crit];
coefs=Flatten@cand/.Rule->(#2&);
If[coefs=!=coefs1,Return[{}]];
cand=cand/.Rule->(#1&);
vt=0&/@vars;
cand={Append[cand,vt]};(*\:041f\:043e\:0441\:043b\:0435\:0434\:043d\:0438\:0439 \:0430\:0440\:0433\:0443\:043c\:0435\:043d\:0442 -- \:0441\:043f\:0438\:0441\:043e\:043a \:0442\:0438\:043f\:043e\:0432*)
Catch[Do[
vt=b*(vt+1);
candn={};
Scan[
Function[c,
fc=First@c;lfc=Length@fc;
Do[
vt1=b*Last@c+fc[[i]];
vt2=Reverse@Sort@vt1;
If[!OrderedQ[{vt,vt2}],
vt=vt2;candn={ReplacePart[c,{1:>Replace[Delete[fc,i],{}->Sequence[]],-1->vt1}]},If[vt===vt2,AppendTo[candn,ReplacePart[c,{1:>Replace[Delete[fc,i],{}->Sequence[]],-1->vt1}]]]
]
,{i,lfc}];
]
,cand];
If[candn==={},Throw[{}]];
cand=candn;
,{n,nt}];
Function[c,
{coefs,SortBy[Thread[vars->Last@c],Last],b}
]/@cand]
];


permute=If[Permute[{1,2,3},{2,3,1}]==={2,3,1},Permute,Permute[#1,InversePermutation[#2]]&];
ipermute=If[Permute[{1,2,3},{2,3,1}]==={2,3,1},Permute[#1,InversePermutation[#2]]&,Permute];


layer[sec:{(0|1)...},depth_Integer,numdepth:(_Integer|\[Infinity]):\[Infinity]]:=Module[
{ndepth=Min[numdepth,depth],nds,nns,pds,pns,perm},
{pds,pns}=Replace[{1,0},Append[Last[Reap[MapIndexed[Sow[First@#2,#1]&,sec],0|1,Rule]],0|1->{}],{1}];
{nds,nns}=Length/@{pds,pns};
perm=Join[pns,pds];
ipermute[#,perm]&/@Flatten[Table[Outer[Join,-Compositions[i,nns],Compositions[depth-i,nds],1],{i,0,ndepth}],2]
]


End[]


EndPackage[]
